<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>共识机制</title>
      <link href="/hexoblog.github.io/2023/06/26/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/"/>
      <url>/hexoblog.github.io/2023/06/26/%E5%85%B1%E8%AF%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="共识机制复习思维导图"><a href="#共识机制复习思维导图" class="headerlink" title="共识机制复习思维导图"></a>共识机制复习思维导图</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.mubucm.com/doc/2WBcYqtQ4Mc</span><br></pre></td></tr></table></figure><h3 id="PBFT篇"><a href="#PBFT篇" class="headerlink" title="PBFT篇"></a>PBFT篇</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.mubucm.com/doc/2QEiE0D1wgc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识kademlia算法</title>
      <link href="/hexoblog.github.io/2023/03/25/%E5%88%9D%E8%AF%86kademlia%E7%AE%97%E6%B3%95/"/>
      <url>/hexoblog.github.io/2023/03/25/%E5%88%9D%E8%AF%86kademlia%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><!--main--><h1 id="P2P网络-前提"><a href="#P2P网络-前提" class="headerlink" title="P2P网络-前提"></a>P2P网络-前提</h1><p>在认识kademlia算法之前，有必要知道P2P网络对等网络的一些知识；</p><h3 id="P2P网络从架构上主要分为非结构化覆盖网和结构化覆盖网。"><a href="#P2P网络从架构上主要分为非结构化覆盖网和结构化覆盖网。" class="headerlink" title="P2P网络从架构上主要分为非结构化覆盖网和结构化覆盖网。"></a>P2P网络从架构上主要分为非结构化覆盖网和结构化覆盖网。</h3><ul><li>非结构化覆盖网要么采用集中的服务器提供信息查询服务，存在单点故障，要么采用洪泛(flooding)搜索机制，查询从一个节点以广 播方式发送到网络中其它节点，查询效率低下，同时产生大量网络带宽，但是其网络结构较为简单，易于实现。</li><li>结构化覆盖网络一般通过杂散(hashing) 方式来组织网络节点和消息 路由，每个节点都有一个唯一的标识(ID)，而每一个存储对象以其对应的散列值作为唯一表示，而且节点标 识的名字空间和对象标识的名字空间</li></ul><h1 id="认识kademlia算法"><a href="#认识kademlia算法" class="headerlink" title="认识kademlia算法"></a>认识kademlia算法</h1><p>当然，kademlia算法严格上来说是属于结构化覆盖网络；如今的以太坊的网络构建层主要的就是基于此算法进行网络层的各种操作以及IPFS内部也使用的是此协议管理网路节点</p><h3 id="一些特性"><a href="#一些特性" class="headerlink" title="一些特性"></a>一些特性</h3><ul><li>Kademlia采用(键，值)对存储和查询对象信息，其中键通过加密算法得到，网络中每个节点也拥有一个标识符-(随机得到)</li></ul><h3 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h3><ol><li><p>由于Kad网络中每个节点会被分配唯一的节点ID，而节点之间可以计算距离，计算距离实际上是异或操作(XOR)，即：给定两个标识符 X，Y，标识符 X，Y之间的距离d(X,Y) &#x3D; X(XOR)Y &#x3D;&gt; 因此可以由此得到一个结论：节点之间的距离越近，意味着节点ID的公共前缀(cpl)越长<br> (注:这里节点间的距离非物理距离)</p></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链原理</title>
      <link href="/hexoblog.github.io/2023/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/"/>
      <url>/hexoblog.github.io/2023/02/01/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h3 id="区块练原理01"><a href="#区块练原理01" class="headerlink" title="区块练原理01:"></a>区块练原理01:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.mubucm.com/doc/1r2dLPHwwDY</span><br></pre></td></tr></table></figure><h3 id="区块链原理02"><a href="#区块链原理02" class="headerlink" title="区块链原理02"></a>区块链原理02</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.mubucm.com/doc/4sdgQfgADWc</span><br></pre></td></tr></table></figure><h3 id="区块链原理03"><a href="#区块链原理03" class="headerlink" title="区块链原理03"></a>区块链原理03</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.mubucm.com/doc/45FKOuocWc</span><br></pre></td></tr></table></figure><h3 id="区块链原理04"><a href="#区块链原理04" class="headerlink" title="区块链原理04"></a>区块链原理04</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.mubucm.com/doc/1UZXhQzqiWc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Defi-交易</title>
      <link href="/hexoblog.github.io/2022/12/17/Defi-%E4%BA%A4%E6%98%93/"/>
      <url>/hexoblog.github.io/2022/12/17/Defi-%E4%BA%A4%E6%98%93/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p><strong>前言:The best way to learn something is to teach others,Second best way to learn something is to do it yourself</strong></p><h1 id="中心化交易所和去中心化交易所的认识"><a href="#中心化交易所和去中心化交易所的认识" class="headerlink" title="中心化交易所和去中心化交易所的认识"></a>中心化交易所和去中心化交易所的认识</h1><hr><h2 id="本质区别（代币的管理方式）"><a href="#本质区别（代币的管理方式）" class="headerlink" title="本质区别（代币的管理方式）"></a>本质区别（代币的管理方式）</h2><ul><li>钱（代币）:在中心化交易所中是存储于交易所钱包中的,也就是说,中心化交易所类似现实世界中的银行为你保管钱财并未你提供金融相关的服务（欧易的中心化式的服务）;<ul><li>而去中心化交易所不保管钱(代币),钱(代币)由用户钱包自行保管,参与去中心化的金融服务需要有用户钱包接入(uniswap).</li></ul></li></ul><h2 id="核心认识（交易的执行方式）"><a href="#核心认识（交易的执行方式）" class="headerlink" title="核心认识（交易的执行方式）"></a>核心认识（交易的执行方式）</h2><ul><li>中心化交易所：用户进行交易时,会向交易所提交交易指令,由交易所进行交易撮合,并将成交后结果告知用户.除了充提币以外,整个交易过程全部是在交易所的服务器中完成,与区块链没有交互;<ul><li><a href="https://zhuanlan.zhihu.com/p/43723567">中心化、去中心化交易所分别是什么？</a><br></li></ul></li><li>去中心化交易所：采用<strong>智能合约</strong>,而不必将其资金的控制权交给任何中介或托管人;<ul><li>这是一种进步,人和机器的互动在交易方面的进步,我认为DEX的发展前景很大,不仅仅因为智能合约;任何只要能够改进金融的本质——交易的方式,我认为都有待思考之处</li></ul></li></ul><hr><h1 id="uinswapV1"><a href="#uinswapV1" class="headerlink" title="uinswapV1"></a>uinswapV1</h1><h2 id="简介-uniswap是什么？"><a href="#简介-uniswap是什么？" class="headerlink" title="简介(uniswap是什么？)"></a>简介(uniswap是什么？)</h2><ul><li>个人理解它是DEX的一种应用、一种目的是成为去中心化交易所的替代品的应用、一种不需要管理员、经营者或者其他有权限的人能够监视或者监听某些行为的应用;<ul><li><a href="https://docs.uniswap.org/protocol/introduction">Uniswap Docs：What Is Uniswap? | Uniswap</a></li></ul></li></ul><h2 id="自动做市商-AMM"><a href="#自动做市商-AMM" class="headerlink" title="自动做市商(AMM)"></a>自动做市商(AMM)</h2><h3 id="定义（何为AMM？）"><a href="#定义（何为AMM？）" class="headerlink" title="定义（何为AMM？）"></a>定义（何为AMM？）</h3><ul><li>抽象的来说,自动化做市商 AMM(Automated market maker) 是一个通用术语,包含不同的去中心化做市商算法;<ul><li>也就是说类似恒定函数做市商(CFMM)、恒定乘积做市商(CPMM)或者恒定和做市商(CSMM)都是它的子集</li></ul></li></ul><h3 id="对比理解AMM存在的意义"><a href="#对比理解AMM存在的意义" class="headerlink" title="对比理解AMM存在的意义"></a>对比理解AMM存在的意义</h3><ul><li>基于订单铺：用户可以在他们选择的限价或者市场价格上设置买卖订单;这和现实生活中很像,CEX平台订单铺的局限性在于中心化的方式可以能够知道某人花费了多少以及平台流通了多少,并不是纯粹的交易,想象如果我想保护自己的隐私,CEX最终能确保吗？<ul><li>采用这种方式的DEX受到<strong>高Gas的限制</strong>（以太坊采用高吞吐量的Solana链缓解这种压力）,但是订单铺的方式仍然受到半中心化之类的质疑<br></li></ul></li><li>基于流动性池：采用与链上流动性资产池（想象一个水池中有两种不同的鱼,两种鱼的数量的乘积或者相加为一定值k,将两种鱼换成两种不同的Token）进行交互;通常,以钱包Provider的身份接入区块链,你的资产依旧掌握在自己手中,并且交易过程中保护了隐私.</li></ul><h2 id="流动性提供者（LP）"><a href="#流动性提供者（LP）" class="headerlink" title="流动性提供者（LP）"></a>流动性提供者（LP）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>所谓流动性性提供者,我们也可以叫做做市商(MM),以单个个体的角度来看,这是一个为交易提供流动性的实体对象(当新的Token上交易所的时候,流动性会成为发行方不得不考虑的方面;<ul><li>往往发行方会鼓励LP将自己的代币放入池子,这样LP可以从提供的代币中获取流动性收益,相应的,池子变得流通起来)</li></ul></li></ul><p><strong>增加流动性和移除流动性都是保持交易池中两个代币比例不变的操作</strong></p><h3 id="模型（恒定乘积公式做市商）"><a href="#模型（恒定乘积公式做市商）" class="headerlink" title="模型（恒定乘积公式做市商）"></a>模型（恒定乘积公式做市商）</h3><ul><li>我们让x,y代表两个不同的token（在v1中有一个肯定是eth）的资产数量,两者的乘积保持一个恒定的值&#x3D;&gt;k,延伸&#x3D;&gt;用 Delta x 数量的token x 交换出 Delta y 数量的 token y:</li></ul><img src="/hexoblog.github.io/2022/12/17/Defi-%E4%BA%A4%E6%98%93/tokenY.png" class title="This is an tokenY image"><ul><li>所以得到Delta y的数量计算对应：</li></ul><img src="/hexoblog.github.io/2022/12/17/Defi-%E4%BA%A4%E6%98%93/DeltaY.png" class title="This is an DeltaY image"><p><strong>分析学习</strong></p><ul><li><p>需要明白的是,V1版本的Uniswap协议是采用Vyper语言进行开发的（而非Solidity,而Vyper和Python相似,但后续被Solidity取代.</p><br></li><li><p>基于Vyper实现的UniswapV1源码的解析：<a href="https://iondex.github.io/2021/07/13/uniswap-v1-source-code/">DeFi发展史：Uniswap V1 源码阅读和分析</a></p><br></li><li><p>Exchange合约(核心)（五个主要功能之一：流动性）</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addLiquidity(min_liquidity: uint256, max_tokens: uint256, deadline: timestamp) -&gt; uint256;</span><br></pre></td></tr></table></figure><img src="/hexoblog.github.io/2022/12/17/Defi-%E4%BA%A4%E6%98%93/addLiquidty.png" class title="This is an addLiquidty image"><p>需要注意的点是,整个交易池是并发的,也就是说,在用户调用<code>addLiquidty()</code>函数的时候池中由于池子中还是在流动,这会出现兑换比例的波动,所以脱离了单纯的按比例互换代币的说法,增加了min_liquidty（用户希望铸造的LP代币数量）、max_tokens（用户想要提供的最大代币数量）、deadline(交易大于该时间,执行回滚)字段进行“用户止损”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">removeLiquidity(amount: uint256, min_eth: uint256(wei), min_tokens: uint256, deadline: timestamp) -&gt; (uint256(wei), uint256)</span><br></pre></td></tr></table></figure><img src="/hexoblog.github.io/2022/12/17/Defi-%E4%BA%A4%E6%98%93/removeLiquidty.png" class title="This is an removeLiquidty image"><ul><li><p>Factory合约:采用工厂合约的设计模式,每个Exchange都可以被追踪</p><br></li><li><p>仿写一个UniswapV1（Solidity+Hardhat）<br>  <a href="https://github.com/Jeiwan/zuniswap">Jeiwan&#x2F;zuniswap: UniswapV1 clone made in educational purposes</a></p></li></ul><hr><h1 id="uniswapV2"><a href="#uniswapV2" class="headerlink" title="uniswapV2"></a>uniswapV2</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>V2 was launched in March 2020 and it was a huge improvement of V1 that allowed direct swaps between any ERC20 tokens, as well as chained swaps between any pairs.</p><h2 id="白皮书学习"><a href="#白皮书学习" class="headerlink" title="白皮书学习"></a>白皮书学习</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/255190320">去中心化交易所：Uniswap v2白皮书中文版</a></p><br></li><li><p>交易对</p><ul><li>理解：相比于V1版本只支持ERC20&#x2F;ETH(注意创建交易池是使用的ETH,实际上交易池中的交易对是ERC20&#x2F;WETH,这样说明是为了强调一种绑定关系),而V2版本允许流动性提供商为任意的两个ERC20代币创建交易对<br>      那为什么V1只支持ERC20&#x2F;ETh pair呢？  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    1.V1中有一个方便快捷的交易路由查询功能,我们只需要在pairs中查询是否存在两个ERC20代币的地址是否存在就可以知道该交易对是否存在.</span><br><span class="line"></span><br><span class="line">    2.在V1中如果要使ERC20/ERC20存在,那么需要承受两次gas、即两次手续费（或者说两次滑点损失(109条消息)[ 深入分析AMM恒定乘积模型的滑点与无常损失_恒定乘积](https://blog.csdn.net/SierraW/article/details/118543720),因为我们使用A代币换ETH需要花费一次gas,而使用ETH换B代币又需要花费一次gas=&gt;V2就是为了解决此问题！</span><br><span class="line"></span><br><span class="line">- V2的解决了两次gas吗？如何解决？</span><br><span class="line">    ```答案是肯定的,在V2版本中,需要创建交易对的A代币和B代币会在pairs中生成一个固定的地址,那么就可以很方便的查询到该交易对是否存在</span><br><span class="line"></span><br><span class="line">    比如在pairs中,A代币和B代币存在一个流动性交易池,B代币和C代币存在一个流动性交易池,我们如果知道这两个交易池的地址信息,我们既可以很容易的创建A代币和C代币的流动性交易池</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Price Oracle(抗风险的价格预言机)</p><ul><li><a href="https://zhuanlan.zhihu.com/p/52369816">什么是区块链预言机</a> (zhihu.com)&#x3D;&gt;本质是一种中间件  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        有一种比较极端的说法：任何能影响价格的因素,都存在套利和风险=&gt;任何与价格有关的地方,都需要Oracle;在V1版本中,在一段时间内抬高ETH价格从而可以存在套利风险或者说使套利成功的安全案例是存在的,所以这种说法是有理可循的.[抵押品不足的贷款攻击](https://www.cnblogs.com/ACaiGarden/p/16073115.html)</span><br><span class="line">        </span><br><span class="line">        V2的Price Oracle避免操纵攻击采取了一种Oracle延迟更新机制TWAP</span><br><span class="line">        原理：简单来说,就是用均价替代预言机的实时报价,通过市场的均衡价格的机制来使得攻击失效或者说削弱攻击;这里题外话,我觉得市场是一种抽象的真实的概念,是一种集体意识的表现,操纵市场的波动也终究取决于人,而如果有少部分人妄想摧毁这种集体意识那么市场本身也应该采取相应的保护措施(股市的熔断机制).</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">- Flash Swap(闪电交换)</span><br></pre></td></tr></table></figure>功能同闪电贷异曲同工,无需抵押品,就可以借出uniswap中的流动性代币,只要在规定时间内完成后,将代币归还就可以完成一笔闪电兑换,同样的如果规定时间内没有归还,那么就会执行原子操作（回滚）,使得借贷失效,借出的代币归还到流动池当中<br>类似在回调函数中拿到钱,然后执行回调函数中执行自己的事务,最后加上把钱还回去的逻辑?<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 合约代码（主要）（solidity）</span><br><span class="line">    - 我看的解析</span><br><span class="line">            [剖析DeFi交易产品之Uniswap：V2上篇 | 登链社区 | 区块链技术社区](https://learnblockchain.cn/article/2824) </span><br><span class="line">            [剖析DeFi交易产品之Uniswap：V2中篇 | 登链社区 | 区块链技术社区](https://learnblockchain.cn/article/3047) </span><br><span class="line">            [剖析DeFi交易产品之Uniswap：V2下篇 | 登链社区 | 区块链技术社区](https://learnblockchain.cn/article/3100)</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    - 拉代码自己解析Uniswap Labs https://github.com/uniswap</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    - 依旧是仿写Programming DeFi: Programming DeFi: Uniswap V2. Part 1 - Going the distance (jeiwan.net)</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    - 前端代码（不是特别会）</span><br><span class="line">    https://www.bilibili.com/video/BV1Uv411N7Ry?spm_id_from=333.999.0.0</span><br><span class="line"></span><br><span class="line">- 题外</span><br></pre></td></tr></table></figure>一个技术的细枝末梢的繁杂可能真的会超乎自己的想象,尤其是我在面临搜索出来的资源的时候,排除能力其实是占很大一部分,但是我又逐渐觉得这是一种必备的核心能力,如果想继续深入互联网世界的话.<br>&#96;&#96;&#96;</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《货币未来：从金本位到区块链》部分书摘</title>
      <link href="/hexoblog.github.io/2022/10/27/%E3%80%8A%E8%B4%A7%E5%B8%81%E6%9C%AA%E6%9D%A5%EF%BC%9A%E4%BB%8E%E9%87%91%E6%9C%AC%E4%BD%8D%E5%88%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%8B%E9%83%A8%E5%88%86%E4%B9%A6%E6%91%98%E7%90%86%E8%A7%A3/"/>
      <url>/hexoblog.github.io/2022/10/27/%E3%80%8A%E8%B4%A7%E5%B8%81%E6%9C%AA%E6%9D%A5%EF%BC%9A%E4%BB%8E%E9%87%91%E6%9C%AC%E4%BD%8D%E5%88%B0%E5%8C%BA%E5%9D%97%E9%93%BE%E3%80%8B%E9%83%A8%E5%88%86%E4%B9%A6%E6%91%98%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="先说说感受，这本书是我在无聊或者厕所的时候看完的，对你没听错，我开始是把这本书当作消遣来读，至于为什么…-可能我也解释不清楚，"><a href="#先说说感受，这本书是我在无聊或者厕所的时候看完的，对你没听错，我开始是把这本书当作消遣来读，至于为什么…-可能我也解释不清楚，" class="headerlink" title="先说说感受，这本书是我在无聊或者厕所的时候看完的，对你没听错，我开始是把这本书当作消遣来读，至于为什么…..可能我也解释不清楚，"></a>先说说感受，这本书是我在无聊或者厕所的时候看完的，对你没听错，我开始是把这本书当作消遣来读，至于为什么…..可能我也解释不清楚，</h2><h2 id="然而，知识有的时候总会在不经意间得到升华，比如可能正在上厕所的我或者你，当然，我只是想说可以在不经意中理解下面的书摘，或许对你有帮助。"><a href="#然而，知识有的时候总会在不经意间得到升华，比如可能正在上厕所的我或者你，当然，我只是想说可以在不经意中理解下面的书摘，或许对你有帮助。" class="headerlink" title="然而，知识有的时候总会在不经意间得到升华，比如可能正在上厕所的我或者你，当然，我只是想说可以在不经意中理解下面的书摘，或许对你有帮助。"></a>然而，知识有的时候总会在不经意间得到升华，比如可能正在上厕所的我或者你，当然，我只是想说可以在不经意中理解下面的书摘，或许对你有帮助。</h2><ul><li><p>“市场越大，专业化分工越多，交易越多，需求耦合的问题就越严重”</p></li><li><p>“实际上，理性市场的运作无须依赖于任何聪明才智。在这样的范式下由一群普通人构成的市场，比在计划模式下由一群天才构成的市场，更能实现高效流畅的运作。”</p></li><li><p>“交易中介是货币之所以成为货币最重要的功能”</p></li><li><p>“商品在时间上的时销性是指它在未来的保值能力，正是因为这种能力，其持有者才通过这种商品储存财富”</p></li><li><p>“不同国家的货币也只是以通用的价值存储载体黄金来衡量经济价值”</p></li><li><p>“对公司来说，公司的任何工作都没有必然的价值，每个人都是可有可无的，因此保住工作机会的唯一方法就是向上级证明自己的价值。在这些公司工作就是一场全职的办公室政治游戏。这样的工作只对那些喜欢支配他人的肤浅的物质主义者有吸引力，为了薪水和有朝一日将虐待加于别人的希望，他们可以忍受多年。毫无疑问，从事这些工作的人经常感到抑郁，需要持续的药物治疗和心理疏导，再多的金钱也抵不上这样的工作环境给人们带来的精神伤害。虽然这些组织没有真正的问责制，但没有生产力的另一面是，新上任的管理者很有可能在几周内就职并完全取消对它们的资金倾“斜。对其中的工作人员来说，这是一种悲惨得多的命运，因为他们通常没有任何实用技能，很难在其他行业找到下一份工作”</p></li><li><p>“有一种常见的误读，认为某种实物商品是数量有限或绝对稀缺的。我们生产任何商品的数量限制从来不是它在地球上的存量有多少，而是投入生产它的精力和时间有多少”</p></li><li><p>“比特币的绝对稀缺性使它在时间上具有很高的适销性”</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 书摘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6简单提炼</title>
      <link href="/hexoblog.github.io/2022/10/25/ES6%E7%AE%80%E5%8D%95%E6%8F%90%E7%82%BC/"/>
      <url>/hexoblog.github.io/2022/10/25/ES6%E7%AE%80%E5%8D%95%E6%8F%90%E7%82%BC/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="前言-为了学习Hardhat框架-从读懂开始慢慢深入-：需要在掌握JS基础后，对以下ES6内容进行学习巩固："><a href="#前言-为了学习Hardhat框架-从读懂开始慢慢深入-：需要在掌握JS基础后，对以下ES6内容进行学习巩固：" class="headerlink" title="#前言:为了学习Hardhat框架(从读懂开始慢慢深入)：需要在掌握JS基础后，对以下ES6内容进行学习巩固："></a>#前言:为了学习Hardhat框架(从读懂开始慢慢深入)：需要在掌握JS基础后，对以下ES6内容进行学习巩固：</h1><h2 id="1-变量声明新增let关键字-注意两点："><a href="#1-变量声明新增let关键字-注意两点：" class="headerlink" title="1.变量声明新增let关键字:注意两点："></a>1.变量声明新增let关键字:注意两点：</h2><ul><li>被let修饰的变量作用域只在代码块内有效(let实际上为 JavaScript 新增了块级作用域)</li><li>被let修饰的变量不存在变量提升</li></ul><h2 id="2-变量声明新增let关键字-注意三点："><a href="#2-变量声明新增let关键字-注意三点：" class="headerlink" title="2.变量声明新增let关键字:注意三点："></a>2.变量声明新增let关键字:注意三点：</h2><ul><li>const声明一个只读的常量。一旦声明，常量的值就不能改变。</li><li>const一旦声明变量，就必须立即初始化，不能留到以后赋值。</li><li>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</li></ul><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><ul><li>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面</li><li>ES6 允许使用“箭头”（&#x3D;&gt;）定义函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分</span><br><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p><h2 id="4-async"><a href="#4-async" class="headerlink" title="4.async"></a>4.async</h2><ul><li>async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function asyncPrint(value, ms) &#123;</span><br><span class="line">  await timeout(ms);</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(&#x27;hello world&#x27;, 50);</span><br></pre></td></tr></table></figure><p>上面代码指定 50 毫秒以后，输出hello world</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统基础学习</title>
      <link href="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="分布式系统概述"><a href="#分布式系统概述" class="headerlink" title="分布式系统概述"></a>分布式系统概述</h1><h3 id="分布式系统存在的意义？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统"><a href="#分布式系统存在的意义？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统" class="headerlink" title="分布式系统存在的意义？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统"></a>分布式系统存在的意义？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统</h3><h3 id="什么是分布式系统？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统"><a href="#什么是分布式系统？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统" class="headerlink" title="什么是分布式系统？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统"></a>什么是分布式系统？：通常来说，当单个无法满足日益增长的计算和存储问题时，且硬件成本的提升，应用无法得到提升的时候，就应该考虑分布式系统</h3><h3 id="分布式拓扑结构？：有四种，分别是："><a href="#分布式拓扑结构？：有四种，分别是：" class="headerlink" title="分布式拓扑结构？：有四种，分别是："></a>分布式拓扑结构？：有四种，分别是：</h3><h4 id="中心化拓扑（传统中心化结构）："><a href="#中心化拓扑（传统中心化结构）：" class="headerlink" title="中心化拓扑（传统中心化结构）："></a>中心化拓扑（传统中心化结构）：</h4><h5 id="特点以及概念？：通过中心索引服务器连接各主机，实际资源在中心化服务器当中"><a href="#特点以及概念？：通过中心索引服务器连接各主机，实际资源在中心化服务器当中" class="headerlink" title="特点以及概念？：通过中心索引服务器连接各主机，实际资源在中心化服务器当中"></a>特点以及概念？：通过中心索引服务器连接各主机，实际资源在中心化服务器当中</h5><h4 id="分布式非机构化P2P网络拓扑："><a href="#分布式非机构化P2P网络拓扑：" class="headerlink" title="分布式非机构化P2P网络拓扑："></a>分布式非机构化P2P网络拓扑：</h4><h5 id="特点以及概念？："><a href="#特点以及概念？：" class="headerlink" title="特点以及概念？："></a>特点以及概念？：</h5><pre><code>    1.结构中的某些节点没有依照预先定义的拓扑（即没有确定拓扑结构支持，因此无法保证资源发现的效率）；    2.采用了重叠网络（就是在现有的网络体系结构上加多一层虚拟网络并将虚拟网络的每个节点与实际网络中的一些节点建立一个连接，从而实现实际网络当中的联通效果）；    3.相比中心拓扑没有中心化服务器的存在，每台机器在网络中是真正的对等关系。    通信通过节点相互传播</code></pre><h4 id="全分布式结构化P2P网络拓扑："><a href="#全分布式结构化P2P网络拓扑：" class="headerlink" title="全分布式结构化P2P网络拓扑："></a>全分布式结构化P2P网络拓扑：</h4><h5 id="特点以及概念？：-1"><a href="#特点以及概念？：-1" class="headerlink" title="特点以及概念？："></a>特点以及概念？：</h5><pre><code>    1.采用分布式哈希表DHT（(Distributed Hash Table）技术来组织网络中的节点（因此也叫DHT网络）    2.采用DHT结构的P2P网络能够自适应节点的动态加入/退出，并且由于重叠（也采用了重叠网络的思想）采用了确定性拓扑，因此只要节点存在于网络中，DHT总能找到它（相比于全分布式非结构化网络发现资源的准确性得到提升）</code></pre><h4 id="半分布式拓扑（混合拓扑结构）-四种基本的网路拓扑结构："><a href="#半分布式拓扑（混合拓扑结构）-四种基本的网路拓扑结构：" class="headerlink" title="半分布式拓扑（混合拓扑结构） 四种基本的网路拓扑结构："></a>半分布式拓扑（混合拓扑结构） 四种基本的网路拓扑结构：</h4><h5 id="特点以及概念？：-2"><a href="#特点以及概念？：-2" class="headerlink" title="特点以及概念？："></a>特点以及概念？：</h5><pre><code>    1.选择性能较高的节点做为超级节点，各个超级节点上存储了系统中其他部分的信息；         2.信息通过各个超级节点间进行传播，然后超级节点向普通节点进行再次传播</code></pre><h3 id="拓展？：不同的区块链采用了不同的分布式系统（比如联盟链采用中心化结构拓扑）"><a href="#拓展？：不同的区块链采用了不同的分布式系统（比如联盟链采用中心化结构拓扑）" class="headerlink" title="拓展？：不同的区块链采用了不同的分布式系统（比如联盟链采用中心化结构拓扑）"></a>拓展？：不同的区块链采用了不同的分布式系统（比如联盟链采用中心化结构拓扑）</h3><h3 id="分布式系统定义？：分布式系统包括分布式存储和分布式计算（计算与存储密切相关，计算来自实时的数据或者数据流或者存储的数据，而计算出的数据也需要存储的），"><a href="#分布式系统定义？：分布式系统包括分布式存储和分布式计算（计算与存储密切相关，计算来自实时的数据或者数据流或者存储的数据，而计算出的数据也需要存储的），" class="headerlink" title="分布式系统定义？：分布式系统包括分布式存储和分布式计算（计算与存储密切相关，计算来自实时的数据或者数据流或者存储的数据，而计算出的数据也需要存储的），"></a>分布式系统定义？：分布式系统包括分布式存储和分布式计算（计算与存储密切相关，计算来自实时的数据或者数据流或者存储的数据，而计算出的数据也需要存储的），</h3><h3 id="由于分布式系统计算机多个节点出现网路故障影响而网络通信是呈指数级增长的，而分布式系统需要持续对外保持服务，即保持较高的容错率–-gt-引出分片"><a href="#由于分布式系统计算机多个节点出现网路故障影响而网络通信是呈指数级增长的，而分布式系统需要持续对外保持服务，即保持较高的容错率–-gt-引出分片" class="headerlink" title="由于分布式系统计算机多个节点出现网路故障影响而网络通信是呈指数级增长的，而分布式系统需要持续对外保持服务，即保持较高的容错率–&gt;引出分片"></a>由于分布式系统计算机多个节点出现网路故障影响而网络通信是呈指数级增长的，而分布式系统需要持续对外保持服务，即保持较高的容错率–&gt;引出分片</h3><h3 id="数据分片？：采用一些方式将数据集划分为更小的不同的独立数据集："><a href="#数据分片？：采用一些方式将数据集划分为更小的不同的独立数据集：" class="headerlink" title="数据分片？：采用一些方式将数据集划分为更小的不同的独立数据集："></a>数据分片？：采用一些方式将数据集划分为更小的不同的独立数据集：</h3><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87.png" class title="This is an 数据分片 image"><h3 id="数据复制？：数据复制将数据集划分为更小的不同的独立数据集（提高了容错性）："><a href="#数据复制？：数据复制将数据集划分为更小的不同的独立数据集（提高了容错性）：" class="headerlink" title="数据复制？：数据复制将数据集划分为更小的不同的独立数据集（提高了容错性）："></a>数据复制？：数据复制将数据集划分为更小的不同的独立数据集（提高了容错性）：</h3><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6.png" class title="This is an 数据复制 image"><h5 id="目前有三种数据复制变更算法："><a href="#目前有三种数据复制变更算法：" class="headerlink" title="目前有三种数据复制变更算法："></a>目前有三种数据复制变更算法：</h5><pre><code>主从复制；多主节点复制；无主节点复制；</code></pre><h3 id="分布式系统的优势（了解）："><a href="#分布式系统的优势（了解）：" class="headerlink" title="分布式系统的优势（了解）："></a>分布式系统的优势（了解）：</h3><h5 id="资源共享：众多节点通过彼此互联，数据库可共享，共享远程文件等"><a href="#资源共享：众多节点通过彼此互联，数据库可共享，共享远程文件等" class="headerlink" title="资源共享：众多节点通过彼此互联，数据库可共享，共享远程文件等"></a>资源共享：众多节点通过彼此互联，数据库可共享，共享远程文件等</h5><h5 id="负载均衡：当单个计算机节点出现故障或负担过重，其他节点可以承担负担过重的节点"><a href="#负载均衡：当单个计算机节点出现故障或负担过重，其他节点可以承担负担过重的节点" class="headerlink" title="负载均衡：当单个计算机节点出现故障或负担过重，其他节点可以承担负担过重的节点"></a>负载均衡：当单个计算机节点出现故障或负担过重，其他节点可以承担负担过重的节点</h5><h5 id="可靠性高、灵活度高"><a href="#可靠性高、灵活度高" class="headerlink" title="可靠性高、灵活度高"></a>可靠性高、灵活度高</h5><h3 id="缺点-了解-："><a href="#缺点-了解-：" class="headerlink" title="缺点(了解)："></a>缺点(了解)：</h3><h5 id="系统复杂"><a href="#系统复杂" class="headerlink" title="系统复杂"></a>系统复杂</h5><h5 id="维护弱于单机系统"><a href="#维护弱于单机系统" class="headerlink" title="维护弱于单机系统"></a>维护弱于单机系统</h5><h5 id="管理成本高"><a href="#管理成本高" class="headerlink" title="管理成本高"></a>管理成本高</h5><h3 id="分布式系统面临的挑战？-普通节点故障；不可靠的网络；异构的机器和网络等"><a href="#分布式系统面临的挑战？-普通节点故障；不可靠的网络；异构的机器和网络等" class="headerlink" title="分布式系统面临的挑战？: 普通节点故障；不可靠的网络；异构的机器和网络等"></a>分布式系统面临的挑战？: 普通节点故障；不可靠的网络；异构的机器和网络等</h3><h1 id="分布式一致性和两个重要理论"><a href="#分布式一致性和两个重要理论" class="headerlink" title="分布式一致性和两个重要理论"></a>分布式一致性和两个重要理论</h1><h3 id="分布式一致性？：分布式一致性指多个节点对某一变量的取值达成一致，一旦达成一致，则变量的取值即被确定"><a href="#分布式一致性？：分布式一致性指多个节点对某一变量的取值达成一致，一旦达成一致，则变量的取值即被确定" class="headerlink" title="分布式一致性？：分布式一致性指多个节点对某一变量的取值达成一致，一旦达成一致，则变量的取值即被确定"></a>分布式一致性？：分布式一致性指多个节点对某一变量的取值达成一致，一旦达成一致，则变量的取值即被确定</h3><h5 id="事务一致性"><a href="#事务一致性" class="headerlink" title="事务一致性"></a>事务一致性</h5><h5 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h5><h5 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h5><h5 id="强一致性：数据更新操作完成后，所有用户或者进程查询都是最近一次成功更新后的结构（需要等待，所以保证强一致性会影响高可用性）"><a href="#强一致性：数据更新操作完成后，所有用户或者进程查询都是最近一次成功更新后的结构（需要等待，所以保证强一致性会影响高可用性）" class="headerlink" title="强一致性：数据更新操作完成后，所有用户或者进程查询都是最近一次成功更新后的结构（需要等待，所以保证强一致性会影响高可用性）"></a>强一致性：数据更新操作完成后，所有用户或者进程查询都是最近一次成功更新后的结构（需要等待，所以保证强一致性会影响高可用性）</h5><h5 id="弱一致性：数据更新后可能只能访问部分或者访问不到"><a href="#弱一致性：数据更新后可能只能访问部分或者访问不到" class="headerlink" title="弱一致性：数据更新后可能只能访问部分或者访问不到"></a>弱一致性：数据更新后可能只能访问部分或者访问不到</h5><h5 id="最终一致性：在一段时间内数据最终达到一致"><a href="#最终一致性：在一段时间内数据最终达到一致" class="headerlink" title="最终一致性：在一段时间内数据最终达到一致"></a>最终一致性：在一段时间内数据最终达到一致</h5><h5 id="因果一致性：事务执行的前后逻辑保持一致"><a href="#因果一致性：事务执行的前后逻辑保持一致" class="headerlink" title="因果一致性：事务执行的前后逻辑保持一致"></a>因果一致性：事务执行的前后逻辑保持一致</h5><h3 id="FLP不可能原理：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不可能存在一个可以解决一致性问题的完美确定性共识算法"><a href="#FLP不可能原理：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不可能存在一个可以解决一致性问题的完美确定性共识算法" class="headerlink" title="FLP不可能原理：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不可能存在一个可以解决一致性问题的完美确定性共识算法"></a>FLP不可能原理：在网络可靠，但允许节点失效（即便只有一个）的最小化异步模型系统中，不可能存在一个可以解决一致性问题的完美确定性共识算法</h3><h3 id="CAP原理：分布式计算系统不可能同时确保以下三个特性：一致性，可用性和分区容忍性："><a href="#CAP原理：分布式计算系统不可能同时确保以下三个特性：一致性，可用性和分区容忍性：" class="headerlink" title="CAP原理：分布式计算系统不可能同时确保以下三个特性：一致性，可用性和分区容忍性："></a>CAP原理：分布式计算系统不可能同时确保以下三个特性：一致性，可用性和分区容忍性：</h3><h1 id="分布式系统中两个原则与多阶段提交（事务可以理解为操作逻辑）"><a href="#分布式系统中两个原则与多阶段提交（事务可以理解为操作逻辑）" class="headerlink" title="分布式系统中两个原则与多阶段提交（事务可以理解为操作逻辑）"></a>分布式系统中两个原则与多阶段提交（事务可以理解为操作逻辑）</h1><h3 id="ACID原则（ACID是关系型数据库的事务需要遵循的原则）：原子性-一致性-隔离性-持久性："><a href="#ACID原则（ACID是关系型数据库的事务需要遵循的原则）：原子性-一致性-隔离性-持久性：" class="headerlink" title="ACID原则（ACID是关系型数据库的事务需要遵循的原则）：原子性 一致性 隔离性 持久性："></a>ACID原则（ACID是关系型数据库的事务需要遵循的原则）：原子性 一致性 隔离性 持久性：</h3><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/ACID.png" class title="This is an ACID image"><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><h5 id="需要先理解网络分区（网络分区时分布式系统的常见异常）：网络分区就是各个子网络内部网络正常，但是网络通信出现异常导致子网路处于孤立状态–-gt-会导致数据不一致："><a href="#需要先理解网络分区（网络分区时分布式系统的常见异常）：网络分区就是各个子网络内部网络正常，但是网络通信出现异常导致子网路处于孤立状态–-gt-会导致数据不一致：" class="headerlink" title="需要先理解网络分区（网络分区时分布式系统的常见异常）：网络分区就是各个子网络内部网络正常，但是网络通信出现异常导致子网路处于孤立状态–&gt;会导致数据不一致："></a>需要先理解网络分区（网络分区时分布式系统的常见异常）：网络分区就是各个子网络内部网络正常，但是网络通信出现异常导致子网路处于孤立状态–&gt;会导致数据不一致：</h5><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E5%AD%A4%E7%AB%8B%E5%BC%82%E5%B8%B8.png" class title="This is an 孤立异常 image"><h5 id="BASE理论是Basically-Avaliable（基本可用），Soft-State（软状态）和Eventually-Consistent-最终一致性"><a href="#BASE理论是Basically-Avaliable（基本可用），Soft-State（软状态）和Eventually-Consistent-最终一致性" class="headerlink" title="BASE理论是Basically Avaliable（基本可用），Soft State（软状态）和Eventually Consistent(最终一致性)"></a>BASE理论是Basically Avaliable（基本可用），Soft State（软状态）和Eventually Consistent(最终一致性)</h5><h3 id="多阶段提交-（前面提到一个完整的理性化的分布式系统是不可能存在的，但是我们依旧可以改进）"><a href="#多阶段提交-（前面提到一个完整的理性化的分布式系统是不可能存在的，但是我们依旧可以改进）" class="headerlink" title="多阶段提交:（前面提到一个完整的理性化的分布式系统是不可能存在的，但是我们依旧可以改进）"></a>多阶段提交:（前面提到一个完整的理性化的分布式系统是不可能存在的，但是我们依旧可以改进）</h3><h5 id="将节点分为协调者和事务参与者"><a href="#将节点分为协调者和事务参与者" class="headerlink" title="将节点分为协调者和事务参与者"></a>将节点分为协调者和事务参与者</h5><h5 id="并将事务划分为"><a href="#并将事务划分为" class="headerlink" title="并将事务划分为"></a>并将事务划分为</h5><pre><code>    第一阶段：尝试预提交阶段    第二阶段：预提交    第三阶段：正式提交</code></pre><h1 id="区块链共识算法的演进"><a href="#区块链共识算法的演进" class="headerlink" title="区块链共识算法的演进"></a>区块链共识算法的演进</h1><h3 id="共识算法概述：区块链系统各分布式节点对事务或者状态的验证、记录、修改等行为达成一致确认的方法，有以下三个特征："><a href="#共识算法概述：区块链系统各分布式节点对事务或者状态的验证、记录、修改等行为达成一致确认的方法，有以下三个特征：" class="headerlink" title="共识算法概述：区块链系统各分布式节点对事务或者状态的验证、记录、修改等行为达成一致确认的方法，有以下三个特征："></a>共识算法概述：区块链系统各分布式节点对事务或者状态的验证、记录、修改等行为达成一致确认的方法，有以下三个特征：</h3><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81.png" class title="This is an 共识算法特征 image"><h3 id="演进："><a href="#演进：" class="headerlink" title="演进："></a>演进：</h3><h5 id="1958年：首次以一致性问题为研究对象"><a href="#1958年：首次以一致性问题为研究对象" class="headerlink" title="1958年：首次以一致性问题为研究对象"></a>1958年：首次以一致性问题为研究对象</h5><h5 id="1982年：拜占庭容错类算法（少数服从多数原则）"><a href="#1982年：拜占庭容错类算法（少数服从多数原则）" class="headerlink" title="1982年：拜占庭容错类算法（少数服从多数原则）"></a>1982年：拜占庭容错类算法（少数服从多数原则）</h5><h5 id="1989年：提出Paxos算法开创非拜占庭容错算法类（少数服从多数原则）"><a href="#1989年：提出Paxos算法开创非拜占庭容错算法类（少数服从多数原则）" class="headerlink" title="1989年：提出Paxos算法开创非拜占庭容错算法类（少数服从多数原则）"></a>1989年：提出Paxos算法开创非拜占庭容错算法类（少数服从多数原则）</h5><h5 id="2008-POW共识"><a href="#2008-POW共识" class="headerlink" title="2008:POW共识"></a>2008:POW共识</h5><h5 id="2008年之后：POS-DPOS-RAFT等"><a href="#2008年之后：POS-DPOS-RAFT等" class="headerlink" title="2008年之后：POS DPOS RAFT等"></a>2008年之后：POS DPOS RAFT等</h5><h3 id="从根据如何选取记账节点的角度，共识算法可分类为："><a href="#从根据如何选取记账节点的角度，共识算法可分类为：" class="headerlink" title="从根据如何选取记账节点的角度，共识算法可分类为："></a>从根据如何选取记账节点的角度，共识算法可分类为：</h3><h5 id="1-证明类机制"><a href="#1-证明类机制" class="headerlink" title="1.证明类机制"></a>1.证明类机制</h5><h5 id="2-选举类机制"><a href="#2-选举类机制" class="headerlink" title="2.选举类机制"></a>2.选举类机制</h5><h5 id="3-混合类机制"><a href="#3-混合类机制" class="headerlink" title="3.混合类机制"></a>3.混合类机制</h5><h1 id="证明类共识算法概述"><a href="#证明类共识算法概述" class="headerlink" title="证明类共识算法概述"></a>证明类共识算法概述</h1><h3 id="概述：被称为“Proof-of-X”类算法，即节点在每一轮共识过程中必须证明自己具有某种特定的能力，以获得记账权和奖励"><a href="#概述：被称为“Proof-of-X”类算法，即节点在每一轮共识过程中必须证明自己具有某种特定的能力，以获得记账权和奖励" class="headerlink" title="概述：被称为“Proof of X”类算法，即节点在每一轮共识过程中必须证明自己具有某种特定的能力，以获得记账权和奖励"></a>概述：被称为“Proof of X”类算法，即节点在每一轮共识过程中必须证明自己具有某种特定的能力，以获得记账权和奖励</h3><h3 id="POW机制：按劳分配的原则，将算法作为记账的主要指标"><a href="#POW机制：按劳分配的原则，将算法作为记账的主要指标" class="headerlink" title="POW机制：按劳分配的原则，将算法作为记账的主要指标"></a>POW机制：按劳分配的原则，将算法作为记账的主要指标</h3><h3 id="POS机制：针对工作量机制存在的不足而设计出来的一种改进型共识机制；基本原理：要求用户证明自己拥有一定数量的数字货币的所有权–即“权益”"><a href="#POS机制：针对工作量机制存在的不足而设计出来的一种改进型共识机制；基本原理：要求用户证明自己拥有一定数量的数字货币的所有权–即“权益”" class="headerlink" title="POS机制：针对工作量机制存在的不足而设计出来的一种改进型共识机制；基本原理：要求用户证明自己拥有一定数量的数字货币的所有权–即“权益”"></a>POS机制：针对工作量机制存在的不足而设计出来的一种改进型共识机制；基本原理：要求用户证明自己拥有一定数量的数字货币的所有权–即“权益”</h3><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/POS.png" class title="This is an POS image"><h5 id="POS币龄：持有货币的时间"><a href="#POS币龄：持有货币的时间" class="headerlink" title="POS币龄：持有货币的时间"></a>POS币龄：持有货币的时间</h5><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E5%B8%81%E9%BE%84.png" class title="This is an 币龄 image"><h5 id="POS利息：即在发现区块后根据一定的利率给付数字货币"><a href="#POS利息：即在发现区块后根据一定的利率给付数字货币" class="headerlink" title="POS利息：即在发现区块后根据一定的利率给付数字货币"></a>POS利息：即在发现区块后根据一定的利率给付数字货币</h5><img src="/hexoblog.github.io/2022/10/20/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/%E5%88%A9%E6%81%AF.png" class title="This is an 利息 image"><h1 id="选举类共识概述"><a href="#选举类共识概述" class="headerlink" title="选举类共识概述"></a>选举类共识概述</h1><h3 id="概述：选举类共识是指节点在每一轮共识过程中通过“投票选举”的方式选出当前轮次的记账节点"><a href="#概述：选举类共识是指节点在每一轮共识过程中通过“投票选举”的方式选出当前轮次的记账节点" class="headerlink" title="概述：选举类共识是指节点在每一轮共识过程中通过“投票选举”的方式选出当前轮次的记账节点"></a>概述：选举类共识是指节点在每一轮共识过程中通过“投票选举”的方式选出当前轮次的记账节点</h3><h3 id="Paxos算法机制：一种选举类算法，采用了少数服从多数的原则"><a href="#Paxos算法机制：一种选举类算法，采用了少数服从多数的原则" class="headerlink" title="Paxos算法机制：一种选举类算法，采用了少数服从多数的原则"></a>Paxos算法机制：一种选举类算法，采用了少数服从多数的原则</h3><h5 id="使用Paxos算法的节点被分为三种不同的角色："><a href="#使用Paxos算法的节点被分为三种不同的角色：" class="headerlink" title="使用Paxos算法的节点被分为三种不同的角色："></a>使用Paxos算法的节点被分为三种不同的角色：</h5><pre><code>   提议者--&gt;提出提案   决策者--&gt;参与决策，回应提案   最终决策学习者--&gt;不参与决策，接受议案</code></pre><h5 id="具体过程这里不过多说明"><a href="#具体过程这里不过多说明" class="headerlink" title="具体过程这里不过多说明"></a>具体过程这里不过多说明</h5><h3 id="Raft算法机制：Raft和Paxos都是为了实现一致性目标，并且Raft算法是基于Paxos算法的"><a href="#Raft算法机制：Raft和Paxos都是为了实现一致性目标，并且Raft算法是基于Paxos算法的" class="headerlink" title="Raft算法机制：Raft和Paxos都是为了实现一致性目标，并且Raft算法是基于Paxos算法的"></a>Raft算法机制：Raft和Paxos都是为了实现一致性目标，并且Raft算法是基于Paxos算法的</h3><p><code>https://zhuanlan.zhihu.com/p/32052223</code></p><h1 id="PBFT（也是选举类共识算法）与蜜罐共识算法"><a href="#PBFT（也是选举类共识算法）与蜜罐共识算法" class="headerlink" title="PBFT（也是选举类共识算法）与蜜罐共识算法"></a>PBFT（也是选举类共识算法）与蜜罐共识算法</h1><h3 id="PBFT-https-zhuanlan-zhihu-com-p-53897982"><a href="#PBFT-https-zhuanlan-zhihu-com-p-53897982" class="headerlink" title="PBFT:https://zhuanlan.zhihu.com/p/53897982"></a>PBFT:<code>https://zhuanlan.zhihu.com/p/53897982</code></h3><h3 id="蜜罐算法"><a href="#蜜罐算法" class="headerlink" title="蜜罐算法"></a>蜜罐算法</h3><h1 id="Avalanche和Algorand算法"><a href="#Avalanche和Algorand算法" class="headerlink" title="Avalanche和Algorand算法"></a>Avalanche和Algorand算法</h1><h3 id="Avalanche-雪崩算法"><a href="#Avalanche-雪崩算法" class="headerlink" title="Avalanche(雪崩算法)"></a>Avalanche(雪崩算法)</h3><h3 id="Algorand算法：https-cloud-tencent-com-developer-news-236363"><a href="#Algorand算法：https-cloud-tencent-com-developer-news-236363" class="headerlink" title="Algorand算法：https://cloud.tencent.com/developer/news/236363"></a>Algorand算法：<code>https://cloud.tencent.com/developer/news/236363</code></h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>solidity中多线继承-super关键字的线性化调用方式</title>
      <link href="/hexoblog.github.io/2022/10/20/solidity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%BB%A7%E6%89%BFsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/"/>
      <url>/hexoblog.github.io/2022/10/20/solidity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%BB%A7%E6%89%BFsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="在一些博客或者文档中我们可能看到对solidity中super关键字的描述是“用于访问（最近的）父合约的一些函数或者状态变量”"><a href="#在一些博客或者文档中我们可能看到对solidity中super关键字的描述是“用于访问（最近的）父合约的一些函数或者状态变量”" class="headerlink" title="在一些博客或者文档中我们可能看到对solidity中super关键字的描述是“用于访问（最近的）父合约的一些函数或者状态变量”"></a>在一些博客或者文档中我们可能看到对solidity中super关键字的描述是“用于访问（最近的）父合约的一些函数或者状态变量”</h2><p>这里有一个简单的具象化但不全面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//定义一个基类合约</span><br><span class="line">contract A&#123;</span><br><span class="line">    string public str01 = &quot;我是A&quot;;</span><br><span class="line"></span><br><span class="line">    function foo() public view virtual returns(string memory)&#123;</span><br><span class="line">        return str01;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//A基类合约的子合约（派生合约）</span><br><span class="line">contract B is A&#123;</span><br><span class="line">    string public str01 = &quot;我是B&quot;;</span><br><span class="line"></span><br><span class="line">    function foo() public view override returns(string memory)&#123;</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译部署B合约，当我们在用外部调用的时候B.foo()函数的时候，但从关键字的理解上来说，super代表最近的父合约，那么这里的父合约就只有A合约，所以会调用A中的foo()方法；</p><p>但是当遇到稍微复杂一些的多线继承的时候（多线继承推荐看登链社区的solidity中文的官方文档<code>https://learnblockchain.cn/docs/solidity/contracts.html#index-17</code>），比如类似的钻石问题，我们就需要搞清楚这个时候的合约编译以及运行情况，这样才能更好的理清思路.<br>这里仍然有一个简单的具象化的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.13;</span><br><span class="line"></span><br><span class="line">/* 继承树：</span><br><span class="line">  God</span><br><span class="line"> /  \</span><br><span class="line">Adam Eve</span><br><span class="line"> \  /</span><br><span class="line">people</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">contract God &#123;</span><br><span class="line">    event Log(string message);</span><br><span class="line"></span><br><span class="line">    function foo() public virtual &#123;</span><br><span class="line">        emit Log(&quot;God.foo called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual &#123;</span><br><span class="line">        emit Log(&quot;God.bar called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Adam is God &#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Adam.foo called&quot;);</span><br><span class="line">        Adam.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Adam.bar called&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Eve is God &#123;</span><br><span class="line">    function foo() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Eve.foo called&quot;);</span><br><span class="line">        Eve.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public virtual override &#123;</span><br><span class="line">        emit Log(&quot;Eve.bar called&quot;);</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract people is Adam, Eve &#123;</span><br><span class="line">    function foo() public override(Adam, Eve) &#123;</span><br><span class="line">        super.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function bar() public override(Adam, Eve) &#123;</span><br><span class="line">        super.bar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代码来自：https://github.com/AmazingAng/WTF-Solidity/blob/main/13_Inheritance/readme.md</span><br></pre></td></tr></table></figure><p>先分析一下这个钻石问题的多线继承关系和合约内容:</p><ul><li>God合约做为基类合约有两个待重写的方法–bar()和foo()</li><li>当God合约的函数被调用时会触发God的Log事件</li><li>Adam和Eve做为God的派生合约都继承了God合约并且都重写了待重写方法-foo()和bar方法</li><li>同时，调用时会触发各自的事件peole继承foo()和bar()合约，作为其子类重写两个方法</li></ul><h3 id="上面合约编译后部署people合约，调用bar-函数，出现结果："><a href="#上面合约编译后部署people合约，调用bar-函数，出现结果：" class="headerlink" title="上面合约编译后部署people合约，调用bar()函数，出现结果："></a>上面合约编译后部署people合约，调用bar()函数，出现结果：</h3><img src="/hexoblog.github.io/2022/10/20/solidity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%BB%A7%E6%89%BFsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/bar01.png" class title="This is an bar01 image"><h3 id="上面合约编译后部署people合约，调用foo-函数，出现结果："><a href="#上面合约编译后部署people合约，调用foo-函数，出现结果：" class="headerlink" title="上面合约编译后部署people合约，调用foo()函数，出现结果："></a>上面合约编译后部署people合约，调用foo()函数，出现结果：</h3><img src="/hexoblog.github.io/2022/10/20/solidity%E4%B8%AD%E5%A4%9A%E7%BA%BF%E7%BB%A7%E6%89%BFsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%BA%BF%E6%80%A7%E5%8C%96%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F/foo01.png" class title="This is an foo01 image"><p><strong>如果你觉得这个运行结果在你的预期之内是一模一样的，那么说明你已经考虑到了：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 多线继承时合约的编译顺序是如何的</span><br><span class="line">2. super关键字的的“最近”是紧紧跟上编译顺序的，而不是简单的父合约</span><br></pre></td></tr></table></figure><p>总之，强调一个问题，在多线继承的时候一定要注意继承时合约的编译顺序（与python相反，一些文章中可以读到不详细了解），并且进一步需要理解的是solidity中合约的编译顺序不是EVM内部决定的，而是依靠我们书写的顺序人为安排的</p><h3 id="那么带着这个结论和对函数调用出现的结果的疑问，先看调用bar函数（依照步骤理解）："><a href="#那么带着这个结论和对函数调用出现的结果的疑问，先看调用bar函数（依照步骤理解）：" class="headerlink" title="那么带着这个结论和对函数调用出现的结果的疑问，先看调用bar函数（依照步骤理解）："></a>那么带着这个结论和对函数调用出现的结果的疑问，先看调用bar函数（依照步骤理解）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 明白编译顺序在编译people合约的时候，people合约继承了两个合约（Aam和Eve），这两个合约都是God的派生合约，那么，编译顺序就是从基类向下：God--&gt;Adam--&gt;Eve--&gt;people(最后是本合约)，或者我们可以改变Eve和Adam的书写顺序``contract people is Adam, Eve``，那么编译顺序就变成了God-&gt;Eve--&gt;Eve--&gt;people</span><br><span class="line">2. 调用bar()函数：执行super.bar，此时依照编译顺序，“最近的父合约”应该是Eve,所以执行Eve.bar()函数</span><br><span class="line">3. Eve.bar()函数首先触发事件，然后调用super.bar()，这时依照编译顺序，“最近的父合约”变为Adam，所以执行Adam.bar()函数</span><br><span class="line">4. Adam,bar()函数首先触发事件，然后调用super.bar(),这时依照编译顺序，“最近的父合约”变为基类合约--God合约，执行God.bar()</span><br><span class="line">5.God.bar()触发事件</span><br><span class="line">所以最后，按次序的三个事件被触发</span><br></pre></td></tr></table></figure><p>同样的依照多线继承的合约编译顺序和super关键字的“最近的父合约”的思路，调用foo()函数，根据代码同样可以知道运行结果是会先触发Eve事件，然后触发Adam事件。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这样理解或许是比较的冗余，但是 不乏是为了理解原理和执行方式，并且很多官方文档并没有对此说明，在没有过多的学过c++或者python的多继承时，希望这篇文章会对你有帮助！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大端小端理解学习</title>
      <link href="/hexoblog.github.io/2022/10/18/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%90%86%E8%A7%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/hexoblog.github.io/2022/10/18/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%90%86%E8%A7%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><h4 id="大端模式：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端"><a href="#大端模式：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端" class="headerlink" title="大端模式：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端"></a>大端模式：高位字节排放在内存的低地址端，低位字节排放在内存的高地址端</h4><h4 id="小端模式：低位字节排放在内存的低地址端，高位字节排放在内存的高地址"><a href="#小端模式：低位字节排放在内存的低地址端，高位字节排放在内存的高地址" class="headerlink" title="小端模式：低位字节排放在内存的低地址端，高位字节排放在内存的高地址"></a>小端模式：低位字节排放在内存的低地址端，高位字节排放在内存的高地址</h4><h1 id="2-具象化的例子："><a href="#2-具象化的例子：" class="headerlink" title="2.具象化的例子："></a>2.具象化的例子：</h1><h4 id="比如有一个数字0x12-34-56-78（12开始高位地址，78是低位地址）"><a href="#比如有一个数字0x12-34-56-78（12开始高位地址，78是低位地址）" class="headerlink" title="比如有一个数字0x12 34 56 78（12开始高位地址，78是低位地址）"></a>比如有一个数字0x12 34 56 78（12开始高位地址，78是低位地址）</h4><h3 id="大端："><a href="#大端：" class="headerlink" title="大端："></a>大端：</h3><h4 id="低地址-——————–-gt-高地址"><a href="#低地址-——————–-gt-高地址" class="headerlink" title="低地址 ——————–&gt; 高地址"></a>低地址 ——————–&gt; 高地址</h4><h4 id="0x12-0x34-0x56-0x78"><a href="#0x12-0x34-0x56-0x78" class="headerlink" title="0x12  |  0x34  |  0x56  |  0x78"></a>0x12  |  0x34  |  0x56  |  0x78</h4><h3 id="小端："><a href="#小端：" class="headerlink" title="小端："></a>小端：</h3><h4 id="低地址-——————–-gt-高地址-1"><a href="#低地址-——————–-gt-高地址-1" class="headerlink" title="低地址 ——————–&gt; 高地址"></a>低地址 ——————–&gt; 高地址</h4><h4 id="0x78-0x56-0x34-0x12"><a href="#0x78-0x56-0x34-0x12" class="headerlink" title="0x78  |  0x56  |  0x34  |  0x12"></a>0x78  |  0x56  |  0x34  |  0x12</h4><h1 id="3-从软件的角度理解：需要知道不同端模式的处理器进行数据传递时必须要考虑端模式的不同，如进行网络数据传递时，必须要考虑端模式的转换"><a href="#3-从软件的角度理解：需要知道不同端模式的处理器进行数据传递时必须要考虑端模式的不同，如进行网络数据传递时，必须要考虑端模式的转换" class="headerlink" title="3.从软件的角度理解：需要知道不同端模式的处理器进行数据传递时必须要考虑端模式的不同，如进行网络数据传递时，必须要考虑端模式的转换"></a>3.从软件的角度理解：需要知道不同端模式的处理器进行数据传递时必须要考虑端模式的不同，如进行网络数据传递时，必须要考虑端模式的转换</h1><h1 id="4-从系统的角度理解：需要知道处理器在硬件上由于端模式问题在设计中有所不同，而不同的硬件系统可能对应着设计的不同的端系统，涉及到硬件设计方面就不再深追"><a href="#4-从系统的角度理解：需要知道处理器在硬件上由于端模式问题在设计中有所不同，而不同的硬件系统可能对应着设计的不同的端系统，涉及到硬件设计方面就不再深追" class="headerlink" title="4.从系统的角度理解：需要知道处理器在硬件上由于端模式问题在设计中有所不同，而不同的硬件系统可能对应着设计的不同的端系统，涉及到硬件设计方面就不再深追"></a>4.从系统的角度理解：需要知道处理器在硬件上由于端模式问题在设计中有所不同，而不同的硬件系统可能对应着设计的不同的端系统，涉及到硬件设计方面就不再深追</h1><p>参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/little-white/p/3236548.html</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Solidity-Study-Notes</title>
      <link href="/hexoblog.github.io/2022/10/15/Solidity-Study-Notes/"/>
      <url>/hexoblog.github.io/2022/10/15/Solidity-Study-Notes/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="personal-Solidity-Study-Notes"><a href="#personal-Solidity-Study-Notes" class="headerlink" title="personal Solidity-Study-Notes"></a>personal Solidity-Study-Notes</h1><h2 id="笔记："><a href="#笔记：" class="headerlink" title="笔记："></a>笔记：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Cofeesy/Solidity-Study-Notes.git</span><br></pre></td></tr></table></figure><h2 id="学习参考资料："><a href="#学习参考资料：" class="headerlink" title="学习参考资料："></a>学习参考资料：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.https://web3dao-cn.github.io/solidity-example/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.https://github.com/AmazingAng/WTF-Solidity.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javascript基础学习--提炼</title>
      <link href="/hexoblog.github.io/2022/10/14/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E6%8F%90%E7%82%BC/"/>
      <url>/hexoblog.github.io/2022/10/14/javascript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-%E6%8F%90%E7%82%BC/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="导论："><a href="#导论：" class="headerlink" title="导论："></a>导论：</h1><h3 id="1-轻量级的脚本语言，“脚本语言”–不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本"><a href="#1-轻量级的脚本语言，“脚本语言”–不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本" class="headerlink" title="1.轻量级的脚本语言，“脚本语言”–不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本"></a>1.轻量级的脚本语言，“脚本语言”–不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本</h3><h3 id="2-一种嵌入式（embedded）语言-一种嵌入式（embedded）语言"><a href="#2-一种嵌入式（embedded）语言-一种嵌入式（embedded）语言" class="headerlink" title="2.一种嵌入式（embedded）语言,一种嵌入式（embedded）语言"></a>2.一种嵌入式（embedded）语言,一种嵌入式（embedded）语言</h3><h3 id="3-核心语法部分相当精简-只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库"><a href="#3-核心语法部分相当精简-只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库" class="headerlink" title="3.核心语法部分相当精简,只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库"></a>3.核心语法部分相当精简,只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库</h3><h3 id="4-它提供的额外-API-可以分成三大类。"><a href="#4-它提供的额外-API-可以分成三大类。" class="headerlink" title="4.它提供的额外 API 可以分成三大类。"></a>4.它提供的额外 API 可以分成三大类。</h3><h5 id="浏览器控制类：操作浏览器"><a href="#浏览器控制类：操作浏览器" class="headerlink" title="浏览器控制类：操作浏览器"></a>浏览器控制类：操作浏览器</h5><h5 id="DOM-类：操作网页的各种元素"><a href="#DOM-类：操作网页的各种元素" class="headerlink" title="DOM 类：操作网页的各种元素"></a>DOM 类：操作网页的各种元素</h5><h5 id="Web-类：实现互联网的各种功能"><a href="#Web-类：实现互联网的各种功能" class="headerlink" title="Web 类：实现互联网的各种功能"></a>Web 类：实现互联网的各种功能</h5><h3 id="5-目前最有希望、前途最光明的计算机语言之一。"><a href="#5-目前最有希望、前途最光明的计算机语言之一。" class="headerlink" title="5.目前最有希望、前途最光明的计算机语言之一。"></a>5.目前最有希望、前途最光明的计算机语言之一。</h3><h3 id="6-能力（作用）：目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。"><a href="#6-能力（作用）：目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。" class="headerlink" title="6.能力（作用）：目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。"></a>6.能力（作用）：目前唯一一种通用的浏览器脚本语言，所有浏览器都支持。它可以让网页呈现各种特殊效果，为用户提供良好的互动体验。</h3><h3 id="7-Node：Node-项目使得-JavaScript-可以用于开发服务器端的大型项目，网站的前后端都用-JavaScript-开发已经成为了现实"><a href="#7-Node：Node-项目使得-JavaScript-可以用于开发服务器端的大型项目，网站的前后端都用-JavaScript-开发已经成为了现实" class="headerlink" title="7.Node：Node 项目使得 JavaScript 可以用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实"></a>7.Node：Node 项目使得 JavaScript 可以用于开发服务器端的大型项目，网站的前后端都用 JavaScript 开发已经成为了现实</h3><h3 id="8-JavaScript-最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序"><a href="#8-JavaScript-最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序" class="headerlink" title="8.JavaScript 最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序"></a>8.JavaScript 最终将能让你只用一种语言，就开发出适应不同平台（包括桌面端、服务器端、手机端）的程序</h3><h3 id="9-一种开放的语言。它的标准-ECMA-262-是-ISO-国际标准"><a href="#9-一种开放的语言。它的标准-ECMA-262-是-ISO-国际标准" class="headerlink" title="9.一种开放的语言。它的标准 ECMA-262 是 ISO 国际标准"></a>9.一种开放的语言。它的标准 ECMA-262 是 ISO 国际标准</h3><h3 id="10-实验环境：推荐Chrome-浏览器的控制台"><a href="#10-实验环境：推荐Chrome-浏览器的控制台" class="headerlink" title="10.实验环境：推荐Chrome 浏览器的控制台"></a>10.实验环境：推荐Chrome 浏览器的控制台</h3><h3 id="11-两种方法进入控制台："><a href="#11-两种方法进入控制台：" class="headerlink" title="11.两种方法进入控制台："></a>11.两种方法进入控制台：</h3><h5 id="直接进入：Ctrl-Shift-J"><a href="#直接进入：Ctrl-Shift-J" class="headerlink" title="直接进入：Ctrl + Shift + J"></a>直接进入：Ctrl + Shift + J</h5><h5 id="开发者工具进入：快捷键是-F12-Ctrl-Shift-I-然后选择-Console-面板"><a href="#开发者工具进入：快捷键是-F12-Ctrl-Shift-I-然后选择-Console-面板" class="headerlink" title="开发者工具进入：快捷键是 F12 ; Ctrl + Shift + I,然后选择 Console 面板"></a>开发者工具进入：快捷键是 F12 ; Ctrl + Shift + I,然后选择 Console 面板</h5><h3 id="12-代码换行：Shift-Enter键"><a href="#12-代码换行：Shift-Enter键" class="headerlink" title="12.代码换行：Shift + Enter键"></a>12.代码换行：Shift + Enter键</h3><h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><h3 id="1-JavaScript-因为互联网而生，紧跟着浏览器的出现而问世"><a href="#1-JavaScript-因为互联网而生，紧跟着浏览器的出现而问世" class="headerlink" title="1.JavaScript 因为互联网而生，紧跟着浏览器的出现而问世"></a>1.JavaScript 因为互联网而生，紧跟着浏览器的出现而问世</h3><h3 id="2-JavaScript-和-Java-两种不一样的语言，但是彼此存在联系。"><a href="#2-JavaScript-和-Java-两种不一样的语言，但是彼此存在联系。" class="headerlink" title="2. JavaScript 和 Java 两种不一样的语言，但是彼此存在联系。"></a>2. JavaScript 和 Java 两种不一样的语言，但是彼此存在联系。</h3><h3 id="3-JavaScript-语法要比-Java-自由得多。"><a href="#3-JavaScript-语法要比-Java-自由得多。" class="headerlink" title="3.JavaScript 语法要比 Java 自由得多。"></a>3.JavaScript 语法要比 Java 自由得多。</h3><h3 id="4-ECMAScript-和-JavaScript-的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。"><a href="#4-ECMAScript-和-JavaScript-的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。" class="headerlink" title="4.ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。"></a>4.ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。</h3><p>基本语法：<br>(1)语句<br>1.执行单位为行,一行一行地执行。一般情况下，每一行就是一个语句。</p><p>2.赋值：var命令(JavaScript 是一种动态类型语言,变量类型没有限制,可以随时改变)</p><p>3.语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p><p>4.分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。</p><p>（2）变量</p><p>1.可以先声明再赋值，或者声明即赋值</p><p>2.如果只是声明变量而没有赋值，则该变量的值是undefined。(使用该变量浏览器会报错)</p><p>3.重新声明一个已经存在的变量，是无效的</p><p>4.覆盖:如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p><p>5.变量提升:JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行</p><p>(3)标识符<br>6.大小写敏感</p><p>7.标识符命名规则:</p><p>  第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。<br>  第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字0-9。</p><p>8.以下保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p><p>(4)注释</p><p>1.单行注释: &#x2F;&#x2F;起头</p><p>2.多行注释: 放在&#x2F;<em>和</em>&#x2F;之间</p><p>3.兼容 HTML 代码<!--注释代码-->的注释</p><p>4.–&gt;只有在行首，才会被当成单行注释，否则会当作正常的运算。</p><p>(5)区块</p><p>1.大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p><p>(6)条件语句(if,switch)</p><p>1.JavaScript 提供if结构和switch结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句</p><p>2.结构类似Java,可单行执行简单语句</p><p>3.支持三元运算符</p><p>(7)循环语句(while,for,do while循环)</p><p>1.结构类似Java,可单行执行简单语句</p><p>(8)程序控制:break 语句和 continue 语句</p><p>1.标签(lable),相当于定位符，用于跳转到程序的任意位置,类似go语言</p><p>数据类型</p><p>1.6种基本数据类型:<br>  数值（number）：整数和小数（比如1和3.14）。<br>  字符串（string）：文本（比如Hello World）。<br>  布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）。<br>  undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何   值。<br>  null：表示空值，即此处的值为空。<br>  对象（object）：各种值组成的集合。</p><p>2.对象是最复杂的数据类型,分成三个子类型。<br>  狭义的对象（object）<br>  数组（array）<br>  函数（function）</p><p>3.typeof运算符:返回一个值的数据类型。</p><p>4.null与undefined都可以表示“没有”，含义非常相似</p><p>5.null与undefined在if语句中，它们都会被自动转为false</p><p>6.null表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入null</p><p>7.除了下面六个值被转为false，其他值都视为true。<br>undefined<br>null<br>false<br>0<br>NaN<br>“”或’’（空字符串）</p><p>8.JavaScript 内部，所有数字都是以64位浮点数形式储存,也就是说,JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）</p><p>9.小数注意也有精度损失</p><p>10.NaN是 JavaScript 的特殊值，表示“非数字,但是它的数据类型依然属于Number</p><p>11.Infinity表示“无穷</p><p>12.Infinity的四则运算，符合无穷的数学计算规则。</p><p>13.isNaN方法可以用来判断一个值是否为NaN。</p><p>14.isFinite方法返回一个布尔值，表示某个值是否为正常的数值。</p><p>15.字符串放在单引号或双引号中都行</p><p>16.单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p><p>17.单引号字符串的内部，使用单引号,必须在内部的单引号前面加上反斜杠，用来转义,双引号内部使用双引号也是一样</p><p>18.字符串默认只能写在一行内</p><p>19.连接运算符（+）可以连接多个单行字符串</p><p>20.反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p><p>21.\n ：换行符；\t ：制表符；\r ：回车键</p><p>22.引用字符串方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined</p><p>23.字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p><p>24.length属性返回字符串的长度</p><p>25.JavaScript 引擎内部，所有字符都用 Unicode 表示</p><p>26.对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p><p>27.对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p><p>28.如果键名是数值，会被自动转为字符串</p><p>29.如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。例如键名为“1p”，这种不是纯数字的类型，但是以数字开头的，需要加上引号</p><p>30.对象的每一个键名又称为“属性”</p><p>31.读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p><p>32.如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p><p>33.方括号内数字键可以不加引号，因为会自动转成字符串。</p><p>34.点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p><p>35.Object.keys()方法查看一个对象本身的所有属性</p><p>36.delete命令用于删除对象的属性，删除成功后返回true</p><p>37.只有一种情况，delete命令会返回false，那就是该属性存在，且不得删除。也就是说删除没有的属性也会返回true</p><p>38.in运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回true，否则返回false</p><p>39.for…in循环用来遍历一个对象的全部属性。</p><p>40.for…in循环有两个使用注意点：</p><p>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。<br>它不仅遍历对象自身的属性，还遍历继承的属性。<br>举例来说，对象都继承了toString属性，但是for…in循环不会遍历到这个属性。</p><p>41.with语句的格式如下：</p><p>with (对象) {<br>  语句;<br>}<br>作用：操作同一个对象的多个属性时，提供一些书写的方便（不推荐使用）</p><p>42.如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量</p><p>43.JavaScript 有三种声明函数的方法:</p><p>  1.function 命令<br>     &#x2F;&#x2F;因为函数是第一等公民，所以如果调用在函数声明前面是不会报错的s<br>  2.函数表达式（变量赋值的写法，将一个匿名函数声明给一个变量）<br>    &#x2F;&#x2F;函数表达式的对于函数表达式，则必须等到解释器执行到它所在的代码行，才会被真正解析执行–&gt;既如果在函数表达式前调用此函数表达式，则会报错<br>  3.Function 构造函数（几乎无人使用）</p><p>44.采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p><p>45.如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p><p>46.JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。–&gt;所以函数被称为第一等公民</p><p>47.JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部</p><p>48.函数的name属性返回函数的名字</p><p>49.函数的length属性返回函数预期传入的参数个数，即函数定义之中的形式参数个数。</p><p>50.函数的toString()方法返回一个字符串，内容是函数的源码</p><p>51.全局变量，局部变量，与Java相似</p><p>52.内部作用域，外部作用域，与Java相似</p><p>53.与全局作用域一样，函数作用域内部也会产生“变量提升”现象。但是函数内部var命令声明的变量，不管在什么位置，变量声明都会被提升到这个函数内部体的头部。</p><p>54.函数参数不是必需的，JavaScript 允许省略参数。</p><p>55.函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递</p><p>56.但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递<br>，所以会涉及到原始值的改变</p><p>57.arguments对象函数体内部读取所有参数</p><p>58.闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。与go语言相似，将一个函数作为返回值，就可以实现函数外部读取到函数内部的变量</p><p>59.根据 JavaScript 的语法，圆括号()跟在函数名之后，表示调用该函数。</p><p>60.function关键字出现在行首，一律解释成语句,所以这时候如果末尾加上()进行自调用就会报错</p><p>61.eval命令接受一个字符串作为参数，并将这个字符串当作语句执行。如果参数字符串无法当作语句运行，那么就会报错</p><p>62.eval缺点：</p><p>不利于引擎优化执行速度<br> 并且eval内部可以改写外部变量，存在安全风险</p><p>63.javascript的数组：任何类型的数据，都可以放入数组。</p><p>64.多维数组，与java相似</p><p>65.本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object</p><p>66.用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p><p>67.数组的length属性，返回数组的成员数量。</p><p>68.数组是一种动态的数据结构，可以随时增减数组的成员，比如length-1</p><p>69.如果人为设置length大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位</p><p>70.数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值</p><p>71.检查某个键名是否存在的运算符in，适用于对象，也适用于数组</p><p>72.for…in循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。但是，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。（但是不推荐使用for…in遍历数组。可以考虑使用for循环或while循环）</p><p>73.当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p><p>74.数组的空位不影响length属性</p><p>75.数组的forEach方法、for…in结构、以及Object.keys方法进行遍历，空位都会被跳过。（如果某个位置是undefined，遍历的时候就不会被跳过。）</p><p>运算符</p><p>1.共提供10个算术运算符，用来完成基本的算术运算。与Java相似</p><p>2.JavaScript 允许非数值的相加</p><p>3.如果运算子是对象，必须先转成原始类型的值，然后再相加<br> 首先，自动调用对象的valueOf方法。<br> 这时再自动调用对象的toString方法，将其转为字符串</p><p>4.比较运算符，与java相似，多了：<br> &#x3D;&#x3D;&#x3D; 严格相等运算符<br> !&#x3D;&#x3D; 严格不相等运算符<br> 与普通相等运算符区别就是如果两个值不是同一类型，严格相等运算符（&#x3D;&#x3D;&#x3D;）直接返回false，普通运算符会先将它们转换成同一个类型，再用严格相等运算符进行比较。</p><p>5.如果两个运算子都是原始类型的值，则是先转成数值再比较</p><p>6.与NaN的比较。任何值（包括NaN本身）与NaN使用非相等运算符进行比较，返回的都是false</p><p>7.undefined和null与自身严格相等。</p><p>8.undefined和null只有与自身比较，或者互相比较时，才会返回true；与其他类型的值比较时，结果都为false</p><p>9.布尔运算符用于将表达式转为布尔值，与Java相似</p><p>10.以下六个值取反后为true，其他值都为false。</p><p>undefined<br>null<br>false<br>0<br>NaN<br>空字符串（’’）</p><p>11.二进制运算符</p><p>12.void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined</p><p>13.圆括号（()）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算。</p><p>语法专题</p><p>1.强制转换主要指使用Number()、String()和Boolean()三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值<br>&#x2F;&#x2F; 空字符串转为0<br>Number(‘’) &#x2F;&#x2F; 0</p><p>&#x2F;&#x2F; 布尔值：true 转成 1，false 转成 0<br>Number(true) &#x2F;&#x2F; 1<br>Number(false) &#x2F;&#x2F; 0</p><p>&#x2F;&#x2F; undefined：转成 NaN<br>Number(undefined) &#x2F;&#x2F; NaN</p><p>&#x2F;&#x2F; null：转成0<br>Number(null) &#x2F;&#x2F; 0</p><p>2.String函数可以将任意类型的值转化成字符串，转换规则如下。</p><p>（1）原始类型值</p><p>数值：转为相应的字符串。<br>字符串：转换后还是原来的值。<br>布尔值：true转为字符串”true”，false转为字符串”false”。<br>undefined：转为字符串”undefined”。<br>null：转为字符串”null”</p><p>3.Boolean()函数可以将任意类型的值转为布尔值。</p><p>它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。<br>undefined<br>null<br>0（包含-0和+0）<br>NaN<br>‘’（空字符串）</p><p>4.自动转换，它是以强制转换为基础的，如“&#x3D;&#x3D;”比较前会进行两边转换</p><p>5.JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象</p><p>6.错误对象的三个函数：</p><p>message：错误提示信息<br>name：错误名称（非标准属性）<br>stack：错误的堆栈（非标准属性）</p><p>7.Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象</p><p>8.SyntaxError对象是解析代码时发生的语法错误。</p><p>9.ReferenceError对象是引用一个不存在的变量时发生的错误</p><p>10.RangeError对象是一个值超出有效范围时发生的错误</p><p>11.TypeError对象是变量或参数不是预期类型时发生的错误</p><p>12.URIError对象是 URI 相关函数的参数不正确时抛出的错误</p><p>13.eval函数没有被正确执行时，会抛出EvalError错误</p><p>14.以上这6种派生错误，连同原始的Error对象，都是构造函数,都可以手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p><p>15.throw语句的作用是手动中断程序执行，抛出一个错误</p><p>16.JavaScript 的所有其他对象都继承自Object对象，即那些对象都是Object的实例。</p><p>17.Object的原型对象：Object.prototype，定义在这个原生对象上的方法可以被所有实例化的对象调用</p><p>18.Object.keys方法和Object.getOwnPropertyNames方法都用来遍历对象的属性。</p><p>19.Object.keys方法和Object.getOwnPropertyNames方法方法类似，参数是一个对象，返回一个数组（成员是该对象的属性）；不同点在设计枚举属性的时候；一般情况下，几乎总是使用Object.keys方法</p><p>20.Object类主要有6个实例方法，很多静态方法</p><p>21.JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为–“属性描述对象”（该属性是否可写、可遍历等等）</p><p>22.属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</p><p>23.一旦定义了取值函数get（或存值函数set），就不能将writable属性设为true，或者同时定义value属性，否则会报错</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杂记02</title>
      <link href="/hexoblog.github.io/2022/10/14/%E6%9D%82%E8%AE%B002/"/>
      <url>/hexoblog.github.io/2022/10/14/%E6%9D%82%E8%AE%B002/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="最令人鼓舞的事情莫过于，人类通过有意识的努力来提升自己的生活能力；而这种能力毋庸置疑。”-–亨利·戴维·梭罗"><a href="#最令人鼓舞的事情莫过于，人类通过有意识的努力来提升自己的生活能力；而这种能力毋庸置疑。”-–亨利·戴维·梭罗" class="headerlink" title="最令人鼓舞的事情莫过于，人类通过有意识的努力来提升自己的生活能力；而这种能力毋庸置疑。”     –亨利·戴维·梭罗"></a>最令人鼓舞的事情莫过于，人类通过有意识的努力来提升自己的生活能力；而这种能力毋庸置疑。”     –亨利·戴维·梭罗</h1><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><h4 id="unicode是ASCII码的超集（ASCII码只能表示英文的存储，而unicode可以存储解释中文或者表情符号之类的东西）"><a href="#unicode是ASCII码的超集（ASCII码只能表示英文的存储，而unicode可以存储解释中文或者表情符号之类的东西）" class="headerlink" title="unicode是ASCII码的超集（ASCII码只能表示英文的存储，而unicode可以存储解释中文或者表情符号之类的东西）"></a>unicode是ASCII码的超集（ASCII码只能表示英文的存储，而unicode可以存储解释中文或者表情符号之类的东西）</h4><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><h4 id="-1"><a href="#-1" class="headerlink" title></a></h4><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><h4 id="-2"><a href="#-2" class="headerlink" title></a></h4><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><h4 id="-3"><a href="#-3" class="headerlink" title></a></h4><h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><h4 id="-4"><a href="#-4" class="headerlink" title></a></h4><h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><h4 id="-5"><a href="#-5" class="headerlink" title></a></h4><h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><h4 id="-6"><a href="#-6" class="headerlink" title></a></h4><h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><h4 id="-7"><a href="#-7" class="headerlink" title></a></h4><h2 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h2><h4 id="-8"><a href="#-8" class="headerlink" title></a></h4><h2 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h2><h4 id="-9"><a href="#-9" class="headerlink" title></a></h4><h2 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h2><h4 id="-10"><a href="#-10" class="headerlink" title></a></h4><h2 id="13"><a href="#13" class="headerlink" title="13."></a>13.</h2><h4 id="-11"><a href="#-11" class="headerlink" title></a></h4><h2 id="14"><a href="#14" class="headerlink" title="14."></a>14.</h2><h4 id="-12"><a href="#-12" class="headerlink" title></a></h4><h2 id="15"><a href="#15" class="headerlink" title="15."></a>15.</h2><h4 id="-13"><a href="#-13" class="headerlink" title></a></h4><h2 id="16"><a href="#16" class="headerlink" title="16."></a>16.</h2><h4 id="-14"><a href="#-14" class="headerlink" title></a></h4><h2 id="17"><a href="#17" class="headerlink" title="17."></a>17.</h2><h4 id="-15"><a href="#-15" class="headerlink" title></a></h4><h2 id="18"><a href="#18" class="headerlink" title="18."></a>18.</h2><h4 id="-16"><a href="#-16" class="headerlink" title></a></h4><h2 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h2><h4 id="-17"><a href="#-17" class="headerlink" title></a></h4><h2 id="20"><a href="#20" class="headerlink" title="20."></a>20.</h2><h4 id="-18"><a href="#-18" class="headerlink" title></a></h4><h2 id="21"><a href="#21" class="headerlink" title="21."></a>21.</h2><h4 id="-19"><a href="#-19" class="headerlink" title></a></h4><h2 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h2><h4 id="-20"><a href="#-20" class="headerlink" title></a></h4><h2 id="23"><a href="#23" class="headerlink" title="23."></a>23.</h2><h4 id="-21"><a href="#-21" class="headerlink" title></a></h4><h2 id="24"><a href="#24" class="headerlink" title="24."></a>24.</h2><h4 id="-22"><a href="#-22" class="headerlink" title></a></h4><h2 id="25"><a href="#25" class="headerlink" title="25."></a>25.</h2><h4 id="-23"><a href="#-23" class="headerlink" title></a></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>以太坊燃料的组成部分以及每一部分的意义</title>
      <link href="/hexoblog.github.io/2022/10/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%87%83%E6%96%99%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E4%BB%A5%E5%8F%8A%E6%AF%8F%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E6%84%8F%E4%B9%89/"/>
      <url>/hexoblog.github.io/2022/10/01/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%87%83%E6%96%99%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%E4%BB%A5%E5%8F%8A%E6%AF%8F%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E6%84%8F%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="伦敦分叉（伦敦升级于-2021-年-8-月-5-日-）后以太坊计价规则得到了改变以太坊的交易费用机制升级并且更容易预估费用"><a href="#伦敦分叉（伦敦升级于-2021-年-8-月-5-日-）后以太坊计价规则得到了改变以太坊的交易费用机制升级并且更容易预估费用" class="headerlink" title="伦敦分叉（伦敦升级于 2021 年 8 月 5 日 ）后以太坊计价规则得到了改变以太坊的交易费用机制升级并且更容易预估费用"></a>伦敦分叉（伦敦升级于 2021 年 8 月 5 日 ）后以太坊计价规则得到了改变以太坊的交易费用机制升级并且更容易预估费用</h1><h3 id="场景：一辆汽车在加油站加油，那么加油这个过程需要注意以下几点："><a href="#场景：一辆汽车在加油站加油，那么加油这个过程需要注意以下几点：" class="headerlink" title="场景：一辆汽车在加油站加油，那么加油这个过程需要注意以下几点："></a>场景：一辆汽车在加油站加油，那么加油这个过程需要注意以下几点：</h3><ul><li>这辆加油加了多少升汽油；</li><li>汽油每升的单价为多少；</li><li>这次加油总费用是多少；</li></ul><h3 id="那我们先假设这辆汽车加了q升汽油，而汽车最大可储油量为t升，并且这个加油站规定汽油每升费用为yGwei（这里的汽油当然不是以真正的货币来衡量，"><a href="#那我们先假设这辆汽车加了q升汽油，而汽车最大可储油量为t升，并且这个加油站规定汽油每升费用为yGwei（这里的汽油当然不是以真正的货币来衡量，" class="headerlink" title="那我们先假设这辆汽车加了q升汽油，而汽车最大可储油量为t升，并且这个加油站规定汽油每升费用为yGwei（这里的汽油当然不是以真正的货币来衡量，"></a>那我们先假设这辆汽车加了q升汽油，而汽车最大可储油量为t升，并且这个加油站规定汽油每升费用为yGwei（这里的汽油当然不是以真正的货币来衡量，</h3><h3 id="在以太坊，Gwei就是Gas的所花费的价值单位），那么这次加油的总费用-在以太坊中是TxFee：交易手续费-就是：总费用-x3D-t-y，当然考虑用户实际使用的支付的油费，退回用户的费用-x3D-t-q-y"><a href="#在以太坊，Gwei就是Gas的所花费的价值单位），那么这次加油的总费用-在以太坊中是TxFee：交易手续费-就是：总费用-x3D-t-y，当然考虑用户实际使用的支付的油费，退回用户的费用-x3D-t-q-y" class="headerlink" title="在以太坊，Gwei就是Gas的所花费的价值单位），那么这次加油的总费用(在以太坊中是TxFee：交易手续费)就是：总费用&#x3D;t*y，当然考虑用户实际使用的支付的油费，退回用户的费用&#x3D;(t-q)*y"></a>在以太坊，Gwei就是Gas的所花费的价值单位），那么这次加油的总费用(在以太坊中是TxFee：交易手续费)就是：总费用&#x3D;t*y，当然考虑用户实际使用的支付的油费，退回用户的费用&#x3D;(t-q)*y</h3><h3 id="如果站在以太坊的视角来看这个问题的话："><a href="#如果站在以太坊的视角来看这个问题的话：" class="headerlink" title="如果站在以太坊的视角来看这个问题的话："></a>如果站在以太坊的视角来看这个问题的话：</h3><ol><li>Gas(Gasuserd):这就是汽车实际的加油数量，即交易执行完成时虚拟机将反馈的总消耗Gas量；</li></ol><ul><li>意义：用于计算TxFee的计量，以太坊执行每一行合约代码都需要相应的Gas，同时Gas在一定程度上对保障了执行合约的安全以及提升了代码的效率问题</li></ul><ol start="2"><li>gasLimit:这是汽车最大可储油量，也就是交易所需要消耗的gas最大上限（相比汽车的最大储油可以事先都知道，以太坊中的gasLimit可以人为制定）；</li></ol><ul><li>意义：避免合约中的错误引起不可预计的燃料消耗导致损失</li></ul><ol start="3"><li>gasPrice:可以类比为汽油每升的单价，也就是交易双方发起交易的一方愿意为支付给矿工的最大费用(maxFeePerGas)，但是注意，gasPrice包含baseFeePerGas(每份燃料的基础费用，由系统自动生成)和maxPriorityFeePerGas(每份燃料支付给矿工的最大小费)</li></ol><ul><li>意义：同样用于计算TxFee的计量，如果想要花费更少，就减少GasPrice，坏处是交易完成需要等待的时间较长，或者提高GasPrice费用减少交易完成时间</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typescript基础学习理解</title>
      <link href="/hexoblog.github.io/2022/09/29/Typescript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3/"/>
      <url>/hexoblog.github.io/2022/09/29/Typescript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="TypeScript-是-JavaScript-的一个超集，支持-ECMAScript-6-标准"><a href="#TypeScript-是-JavaScript-的一个超集，支持-ECMAScript-6-标准" class="headerlink" title="TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准"></a>TypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准</h2><h3 id="如何理解超集？-从编译原理中看"><a href="#如何理解超集？-从编译原理中看" class="headerlink" title="如何理解超集？(从编译原理中看)"></a>如何理解超集？(从编译原理中看)</h3><ol><li><p>根据官方的配置方式，使用vscode作为TypeScript的编译器执行程序代码，这是在控制台编译运行的方法：</p><img src="/hexoblog.github.io/2022/09/29/Typescript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3/hello.png" class title="This is an runhello image"></li><li><p>如上图使用tsc方式来运行以.ts结尾的文件,编译好后,生成了一个.js结尾的文件,文件名和之前命名相同:</p><img src="/hexoblog.github.io/2022/09/29/Typescript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3/tsc.png" class title="This is an runjs image"></li><li><p>于是我们使用node执行运行.js文件,这就是编译运行TypeScript代码的方式</p></li></ol><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><h3 id="需要注意以下三点"><a href="#需要注意以下三点" class="headerlink" title="需要注意以下三点:"></a>需要注意以下三点:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//any关键词:用来表示允许赋值为任意类型。</span><br><span class="line"></span><br><span class="line">  //1.关键词为any</span><br><span class="line"></span><br><span class="line">  //2.特点:被any修饰的变量后续可以改变类型(编译不会出现报错):</span><br><span class="line"></span><br><span class="line">  let str02:any = &quot;any&quot;;</span><br><span class="line">  console.log(str02);</span><br><span class="line">  str02 = 7;//编译通过</span><br><span class="line">  console.log(str02);</span><br><span class="line"></span><br><span class="line">  //3.注意:  </span><br><span class="line">   //声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。</span><br><span class="line"></span><br><span class="line">   //对一个未声明类型的变量赋值(区别于命名连着赋值,是先声明,然后换行赋值),该变量默认为any类型:</span><br><span class="line">   let str04;//会被识别为任意类型,类型随后续赋值类型改变</span><br><span class="line">   console.log(typeof str04);//undefined</span><br><span class="line">   str04 = &quot;333&quot;;</span><br><span class="line">   console.log(typeof str04);//string</span><br><span class="line">   str04 = 7;</span><br><span class="line">   console.log(typeof str04);//number</span><br></pre></td></tr></table></figure><h2 id="类型推论-TypeScript相比于JavaScript的特色"><a href="#类型推论-TypeScript相比于JavaScript的特色" class="headerlink" title="类型推论(TypeScript相比于JavaScript的特色)"></a>类型推论(TypeScript相比于JavaScript的特色)</h2><h3 id="理解类型推断"><a href="#理解类型推断" class="headerlink" title="理解类型推断:"></a>理解类型推断:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//类型推断:</span><br><span class="line"></span><br><span class="line">  //1.是什么?</span><br><span class="line">  //--&gt;在给一个变量赋值的时候,编译会自行推断变量的类型并与该变量绑定</span><br><span class="line">  let str02 = &quot;www&quot;;//已经声明并赋值:等价于:let str02:string = &quot;www&quot;;</span><br><span class="line">  console.log(typeof str02);//string--&gt;类型推断为string</span><br><span class="line">  str02 = 7;//编译报错</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><h3 id="联合类型我认为是typescript对类型限制使用any解决变为更加灵活的另一种方式-联合类型（Union-Types）表示取值可以为多种类型中的一种。以符号”-”为标志"><a href="#联合类型我认为是typescript对类型限制使用any解决变为更加灵活的另一种方式-联合类型（Union-Types）表示取值可以为多种类型中的一种。以符号”-”为标志" class="headerlink" title="联合类型我认为是typescript对类型限制使用any解决变为更加灵活的另一种方式:联合类型（Union Types）表示取值可以为多种类型中的一种。以符号”|”为标志:"></a>联合类型我认为是typescript对类型限制使用any解决变为更加灵活的另一种方式:联合类型（Union Types）表示取值可以为多种类型中的一种。以符号”|”为标志:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let str01: string|number;</span><br><span class="line">str01 = &quot;www&quot;;</span><br><span class="line">str01 = 777;</span><br><span class="line">console.log(str01);//777</span><br><span class="line"></span><br><span class="line">//使用声明的类型之外的类型覆盖:</span><br><span class="line">str01 = true;//编译报错</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="TypeScript中的接口我认为非常的灵活-不是像Java中”抽象方法的集合体”般的描述-将可存在的属性和方法结合成一个更加灵活广阔的”接口”"><a href="#TypeScript中的接口我认为非常的灵活-不是像Java中”抽象方法的集合体”般的描述-将可存在的属性和方法结合成一个更加灵活广阔的”接口”" class="headerlink" title="TypeScript中的接口我认为非常的灵活,不是像Java中”抽象方法的集合体”般的描述,将可存在的属性和方法结合成一个更加灵活广阔的”接口”"></a>TypeScript中的接口我认为非常的灵活,不是像Java中”抽象方法的集合体”般的描述,将可存在的属性和方法结合成一个更加灵活广阔的”接口”</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//定义Person接口属性</span><br><span class="line">interface Person&#123;</span><br><span class="line">    name:string;//属性声明--&gt;变量:类型</span><br><span class="line">    age:number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//上面Person接口定义了两个属性,我们用实例实现:</span><br><span class="line">let tom:Person=&#123; 实现方式:let 实例名:接口名&#123;...&#125;</span><br><span class="line">    name:&quot;tom&quot;;</span><br><span class="line">    age:19;</span><br><span class="line">    //birth:2002.02.13--&gt;去掉注释编译报错:这种接口不能够多属性也不能够少属性或者方法</span><br><span class="line">&#125;</span><br><span class="line">//</span><br></pre></td></tr></table></figure><h3 id="TypeScript的接口的灵活性一是体现在属性定义-另一个就是满足属性完整性-注意掌握四点属性"><a href="#TypeScript的接口的灵活性一是体现在属性定义-另一个就是满足属性完整性-注意掌握四点属性" class="headerlink" title="TypeScript的接口的灵活性一是体现在属性定义,另一个就是满足属性完整性(注意掌握四点属性):"></a>TypeScript的接口的灵活性一是体现在属性定义,另一个就是满足属性完整性(注意掌握四点属性):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.确定属性和2.可选属性</span><br><span class="line">interface Person&#123;</span><br><span class="line">    name:string;//1.确定属性</span><br><span class="line">    age?:number;//2.age属性变为可选,意思是可以实例可以不存在该属性,格式:变量?:变量属性;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom:Person&#123;</span><br><span class="line">    name:tom;</span><br><span class="line">    //age:28;--&gt;去掉注释该行不会报错</span><br><span class="line">    //gender:&quot;male&quot;;//去掉注释该行报错,不能出现未定义的属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">3.任意属性:</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: number]: string;//任意属性格式解析:propName为自定义属性名,number是属性名的类型,string是这个属性键值对对应的类型</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">注意:一旦定义了任意属性,那么确定属性和可选属性的类型都必须是它的子集--&gt;如何理解子集?,以上面例子为例,name属性为确定属性他的类型为string,age属性为可选属性,类型为number,那么确定属性和可选属性的集合就是[number,string],下面任意属性的属性名是number,属性的值为string类型,那么任意属性的集合就是[number,string],那么符合子集说明,程序不会报错,如果将任意属性的属性对应的值改为string,那么任意属性的类型集合就是[string,string],不符合子集说明,编译报错</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">4.只读属性:--readonly</span><br><span class="line">interface Person &#123;</span><br><span class="line">  readonly id: number;//理解:readonly关键字--属性的修饰符</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//readonly理解:只读约束在第一次给对象赋值的时候就有,而不是第一次给只读修饰的属性赋值的时候</span><br><span class="line">let tom02: Person = &#123;</span><br><span class="line">  id:1,</span><br><span class="line">  name: &#x27;Tom&#x27;,</span><br><span class="line">  gender: &#x27;male&#x27;</span><br><span class="line">&#125;;//这是第一次给对象赋值的时候，所有属性都需要依次赋值</span><br><span class="line"></span><br><span class="line">//tom.id = 89757;</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="TypeScript相比于JavaScript最大的特点就是对函数的输入输出进行了强调，即通过限制函数输入输出的类型使得函数变得灵活："><a href="#TypeScript相比于JavaScript最大的特点就是对函数的输入输出进行了强调，即通过限制函数输入输出的类型使得函数变得灵活：" class="headerlink" title="TypeScript相比于JavaScript最大的特点就是对函数的输入输出进行了强调，即通过限制函数输入输出的类型使得函数变得灵活："></a>TypeScript相比于JavaScript最大的特点就是对函数的输入输出进行了强调，即通过限制函数输入输出的类型使得函数变得灵活：</h3><h3 id="1-对函数声明式函数定义："><a href="#1-对函数声明式函数定义：" class="headerlink" title="1.对函数声明式函数定义："></a>1.对函数声明式函数定义：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun sum(x:number,y:number):number&#123;</span><br><span class="line"> return x+y;  </span><br><span class="line">&#125;</span><br><span class="line">//上面这段函数需要注意两点：</span><br><span class="line">  //1.函数接收两个类型为number类型的实例参数，返回number类型的结果，如果传入类型不对会出现编译报错</span><br><span class="line">  //2.函数的实际输入参数少于或多于形式参数都会编译报错</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-对函数表达式定义"><a href="#2-对函数表达式定义" class="headerlink" title="2.对函数表达式定义"></a>2.对函数表达式定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//新的知识：&quot;=&gt;&quot;符号</span><br><span class="line">//用途：这个符号可以用来定义函数：</span><br><span class="line"></span><br><span class="line">//通常我们定义一个函数表达式：</span><br><span class="line">let func01 = function(x:number,y:number) :number&#123;return x-y;&#125;</span><br><span class="line">console.log(typeof func01);//function</span><br><span class="line"></span><br><span class="line">//这种方式编译不会报错，因为编译时对&quot;=&quot;右边进行了类型推断，将function和fun01进行了绑定</span><br><span class="line"></span><br><span class="line">//但是我们可以使用&quot;=&gt;&quot;给函数表达式手动添加类型：</span><br><span class="line">let func02:(x:number,y:number)=&gt;number = function(x:number,y:number) :number&#123;return x-y;&#125;</span><br><span class="line"></span><br><span class="line">//格式解析：首先和所有变量定义类型一样&quot;:&quot;符号，然后声明输入的属性及其类型，多个输入添加&quot;()&quot;，然后使用&quot;=&gt;&quot;连接输出属性的类型</span><br><span class="line">//这里注意不要混淆了TypeScript和ES6中对于&quot;=&gt;&quot;符号是有区别的，TS中只表示函数的定义</span><br></pre></td></tr></table></figure><h3 id="3-接口定义函数的形状和可选属性："><a href="#3-接口定义函数的形状和可选属性：" class="headerlink" title="3.接口定义函数的形状和可选属性："></a>3.接口定义函数的形状和可选属性：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//掌握格式即可：</span><br><span class="line">interface Func&#123;</span><br><span class="line">  (source:string,subString:string):boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可选属性：和接口可选属性一样，让函数的传入参数不再必须多于或者少于：</span><br><span class="line">function buildname(firstName:string,lastName?:string)//lastName为可选属性&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TypeScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>杂记01</title>
      <link href="/hexoblog.github.io/2022/09/23/%E6%9D%82%E8%AE%B001/"/>
      <url>/hexoblog.github.io/2022/09/23/%E6%9D%82%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="最初理解事物的惰性可能会让你不知所措"><a href="#最初理解事物的惰性可能会让你不知所措" class="headerlink" title="最初理解事物的惰性可能会让你不知所措"></a><strong>最初理解事物的惰性可能会让你不知所措</strong></h1><h2 id="01"><a href="#01" class="headerlink" title="01."></a>01.</h2><h4 id="众所周知，任何一个公司、组织、或者是机构，都遵循同一套组织架构原则，那就是“下级服从上级、少数服从多数”原则。而对于区块链技术来说，只遵循这个原则的后半句，那就是“少数服从多数”，不存在“下级服从上级”。–-gt-进而言之，在区块链中，根本就没有什么所谓“上级”的概念"><a href="#众所周知，任何一个公司、组织、或者是机构，都遵循同一套组织架构原则，那就是“下级服从上级、少数服从多数”原则。而对于区块链技术来说，只遵循这个原则的后半句，那就是“少数服从多数”，不存在“下级服从上级”。–-gt-进而言之，在区块链中，根本就没有什么所谓“上级”的概念" class="headerlink" title="众所周知，任何一个公司、组织、或者是机构，都遵循同一套组织架构原则，那就是“下级服从上级、少数服从多数”原则。而对于区块链技术来说，只遵循这个原则的后半句，那就是“少数服从多数”，不存在“下级服从上级”。–&gt;进而言之，在区块链中，根本就没有什么所谓“上级”的概念"></a>众所周知，任何一个公司、组织、或者是机构，都遵循同一套组织架构原则，那就是“下级服从上级、少数服从多数”原则。而对于区块链技术来说，只遵循这个原则的后半句，那就是“少数服从多数”，不存在“下级服从上级”。–&gt;进而言之，在区块链中，根本就没有什么所谓“上级”的概念</h4><h2 id="02"><a href="#02" class="headerlink" title="02."></a>02.</h2><h4 id="地址只是账户在区块链上一个简单的占位符。用于存储-token-或者其他只能由特定私钥解锁的资产。"><a href="#地址只是账户在区块链上一个简单的占位符。用于存储-token-或者其他只能由特定私钥解锁的资产。" class="headerlink" title="地址只是账户在区块链上一个简单的占位符。用于存储 token 或者其他只能由特定私钥解锁的资产。"></a>地址只是账户在区块链上一个简单的占位符。用于存储 token 或者其他只能由特定私钥解锁的资产。</h4><h2 id="03"><a href="#03" class="headerlink" title="03."></a>03.</h2><h4 id="简单的说，智能合约就是可执行代码。这段代码被部署到智能合约账户的一个地址，区块链上的占位符，其私钥是未知的。而账户可以理解为是地址的一种抽象表达（好比一个大中国（一个以太坊系统），每个中国公民都有一个身份地址（地址），可以通过身份地址找到这个人（账户））"><a href="#简单的说，智能合约就是可执行代码。这段代码被部署到智能合约账户的一个地址，区块链上的占位符，其私钥是未知的。而账户可以理解为是地址的一种抽象表达（好比一个大中国（一个以太坊系统），每个中国公民都有一个身份地址（地址），可以通过身份地址找到这个人（账户））" class="headerlink" title="简单的说，智能合约就是可执行代码。这段代码被部署到智能合约账户的一个地址，区块链上的占位符，其私钥是未知的。而账户可以理解为是地址的一种抽象表达（好比一个大中国（一个以太坊系统），每个中国公民都有一个身份地址（地址），可以通过身份地址找到这个人（账户））"></a>简单的说，智能合约就是可执行代码。这段代码被部署到智能合约账户的一个地址，区块链上的占位符，其私钥是未知的。而账户可以理解为是地址的一种抽象表达（好比一个大中国（一个以太坊系统），每个中国公民都有一个身份地址（地址），可以通过身份地址找到这个人（账户））</h4><h2 id="04"><a href="#04" class="headerlink" title="04."></a>04.</h2><h4 id="要确定智能合约地址，你需要两样东西：发送账户地址和部署合约时的-nonce-交易数-也就是说智能合约的代码是部署在智能合约账户的地址上的（智能合约地址：智能合约账户上的一个占位符），而智能合约的地址是由在创建合约时可以确定的"><a href="#要确定智能合约地址，你需要两样东西：发送账户地址和部署合约时的-nonce-交易数-也就是说智能合约的代码是部署在智能合约账户的地址上的（智能合约地址：智能合约账户上的一个占位符），而智能合约的地址是由在创建合约时可以确定的" class="headerlink" title="要确定智能合约地址，你需要两样东西：发送账户地址和部署合约时的 nonce(交易数),也就是说智能合约的代码是部署在智能合约账户的地址上的（智能合约地址：智能合约账户上的一个占位符），而智能合约的地址是由在创建合约时可以确定的"></a>要确定智能合约地址，你需要两样东西：发送账户地址和部署合约时的 nonce(交易数),也就是说智能合约的代码是部署在智能合约账户的地址上的（智能合约地址：智能合约账户上的一个占位符），而智能合约的地址是由在创建合约时可以确定的</h4><h3 id="05"><a href="#05" class="headerlink" title="05."></a>05.</h3><h4 id="以太坊中有两类账户，它们共用同一个地址空间"><a href="#以太坊中有两类账户，它们共用同一个地址空间" class="headerlink" title="以太坊中有两类账户，它们共用同一个地址空间:"></a>以太坊中有两类账户，它们共用同一个地址空间:</h4><h4 id="外部账户，是由以太坊网络的人类用户创建的帐户。它与公钥、私钥对相关，他是通过对公钥进行二次哈希后结果的最后20个字节导出的。"><a href="#外部账户，是由以太坊网络的人类用户创建的帐户。它与公钥、私钥对相关，他是通过对公钥进行二次哈希后结果的最后20个字节导出的。" class="headerlink" title="外部账户，是由以太坊网络的人类用户创建的帐户。它与公钥、私钥对相关，他是通过对公钥进行二次哈希后结果的最后20个字节导出的。"></a>外部账户，是由以太坊网络的人类用户创建的帐户。它与公钥、私钥对相关，他是通过对公钥进行二次哈希后结果的最后20个字节导出的。</h4><h4 id="合约账户，：由智能合约的代码控制。只有合约账户才有代码，其中存储的是-codeHash（这个账户的以太坊虚拟机代码的哈希值），这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。"><a href="#合约账户，：由智能合约的代码控制。只有合约账户才有代码，其中存储的是-codeHash（这个账户的以太坊虚拟机代码的哈希值），这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。" class="headerlink" title="合约账户，：由智能合约的代码控制。只有合约账户才有代码，其中存储的是 codeHash（这个账户的以太坊虚拟机代码的哈希值），这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。"></a>合约账户，：由智能合约的代码控制。只有合约账户才有代码，其中存储的是 codeHash（这个账户的以太坊虚拟机代码的哈希值），这个字段在生成后是不可修改的，这意味着智能合约代码是不可修改的。</h4><h2 id="06"><a href="#06" class="headerlink" title="06."></a>06.</h2><h4 id="这样看，外部账户就相当于我们平时保存的私人钥匙，只是这把钥匙不同，但打开的门确是相同的，而我们要学习的重点就是这个合约账户，因为他是在外部账户创立（即私钥随机生成后，私钥生成公钥）的时候创建合约就能够确定的一个能够识别不同操作对象-应该说是智能合约代码编译、部署在区块链上-的一个“人”，或者说是一个唯一识别这个合约的归属的对象，之后由这个对象绑定这些智能合约和智能合约相关的操作"><a href="#这样看，外部账户就相当于我们平时保存的私人钥匙，只是这把钥匙不同，但打开的门确是相同的，而我们要学习的重点就是这个合约账户，因为他是在外部账户创立（即私钥随机生成后，私钥生成公钥）的时候创建合约就能够确定的一个能够识别不同操作对象-应该说是智能合约代码编译、部署在区块链上-的一个“人”，或者说是一个唯一识别这个合约的归属的对象，之后由这个对象绑定这些智能合约和智能合约相关的操作" class="headerlink" title="这样看，外部账户就相当于我们平时保存的私人钥匙，只是这把钥匙不同，但打开的门确是相同的，而我们要学习的重点就是这个合约账户，因为他是在外部账户创立（即私钥随机生成后，私钥生成公钥）的时候创建合约就能够确定的一个能够识别不同操作对象(应该说是智能合约代码编译、部署在区块链上)的一个“人”，或者说是一个唯一识别这个合约的归属的对象，之后由这个对象绑定这些智能合约和智能合约相关的操作"></a>这样看，外部账户就相当于我们平时保存的私人钥匙，只是这把钥匙不同，但打开的门确是相同的，而我们要学习的重点就是这个合约账户，因为他是在外部账户创立（即私钥随机生成后，私钥生成公钥）的时候创建合约就能够确定的一个能够识别不同操作对象(应该说是智能合约代码编译、部署在区块链上)的一个“人”，或者说是一个唯一识别这个合约的归属的对象，之后由这个对象绑定这些智能合约和智能合约相关的操作</h4><h2 id="07"><a href="#07" class="headerlink" title="07."></a>07.</h2><h4 id="智能合约执行是编译一句执行一句，每执行一次都是需要消耗gas的-交易是需要成本的，保障安全；并且燃料可以优化智能合约的执行效率–-gt-我们执行智能合约是需要将成本考虑在内的，这样可以使我们反视考虑智能合约代码的优化"><a href="#智能合约执行是编译一句执行一句，每执行一次都是需要消耗gas的-交易是需要成本的，保障安全；并且燃料可以优化智能合约的执行效率–-gt-我们执行智能合约是需要将成本考虑在内的，这样可以使我们反视考虑智能合约代码的优化" class="headerlink" title="智能合约执行是编译一句执行一句，每执行一次都是需要消耗gas的(交易是需要成本的，保障安全；并且燃料可以优化智能合约的执行效率–&gt;我们执行智能合约是需要将成本考虑在内的，这样可以使我们反视考虑智能合约代码的优化)"></a>智能合约执行是编译一句执行一句，每执行一次都是需要消耗gas的(交易是需要成本的，保障安全；并且燃料可以优化智能合约的执行效率–&gt;我们执行智能合约是需要将成本考虑在内的，这样可以使我们反视考虑智能合约代码的优化)</h4><h2 id="08"><a href="#08" class="headerlink" title="08."></a>08.</h2><h4 id="合约调用合约大概是可以理解为线程之间的通信，因为是一个节点内部调用的过程，是不需要序列化的"><a href="#合约调用合约大概是可以理解为线程之间的通信，因为是一个节点内部调用的过程，是不需要序列化的" class="headerlink" title="合约调用合约大概是可以理解为线程之间的通信，因为是一个节点内部调用的过程，是不需要序列化的"></a>合约调用合约大概是可以理解为线程之间的通信，因为是一个节点内部调用的过程，是不需要序列化的</h4><h2 id="09"><a href="#09" class="headerlink" title="09."></a>09.</h2><h4 id="EVM计算机架构类似于哈佛架构而不是冯诺依曼结构（哈佛架构是指指令和数据分开存储，而冯诺依曼结构指令和数据统一存储）"><a href="#EVM计算机架构类似于哈佛架构而不是冯诺依曼结构（哈佛架构是指指令和数据分开存储，而冯诺依曼结构指令和数据统一存储）" class="headerlink" title="EVM计算机架构类似于哈佛架构而不是冯诺依曼结构（哈佛架构是指指令和数据分开存储，而冯诺依曼结构指令和数据统一存储）"></a>EVM计算机架构类似于哈佛架构而不是冯诺依曼结构（哈佛架构是指指令和数据分开存储，而冯诺依曼结构指令和数据统一存储）</h4><h2 id="10"><a href="#10" class="headerlink" title="10."></a>10.</h2><h4 id="从某种意义上来说，智能合约不是完整的图灵完备的，1-存储空间并不是无限-2-执行代码需要消耗gas"><a href="#从某种意义上来说，智能合约不是完整的图灵完备的，1-存储空间并不是无限-2-执行代码需要消耗gas" class="headerlink" title="从某种意义上来说，智能合约不是完整的图灵完备的，1.存储空间并不是无限 2.执行代码需要消耗gas"></a>从某种意义上来说，智能合约不是完整的图灵完备的，1.存储空间并不是无限 2.执行代码需要消耗gas</h4><h2 id="11"><a href="#11" class="headerlink" title="11."></a>11.</h2><h4 id="区分动态语言和静态语言：类型系统按照「类型检查的时机」来分类："><a href="#区分动态语言和静态语言：类型系统按照「类型检查的时机」来分类：" class="headerlink" title="区分动态语言和静态语言：类型系统按照「类型检查的时机」来分类："></a>区分动态语言和静态语言：类型系统按照「类型检查的时机」来分类：</h4><h4 id="动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误"><a href="#动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误" class="headerlink" title="动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误"></a>动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误</h4><h4 id="静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误"><a href="#静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误" class="headerlink" title="静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误"></a>静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误</h4><h2 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h2><h4 id="区分弱类型和强类型：类型系统按照「是否允许隐式类型转换」-也就是自动类型转换–-gt-具体表现为一个变量声明类型后后序可以用其他类型覆盖-来分类，可以分为强类型和弱类型："><a href="#区分弱类型和强类型：类型系统按照「是否允许隐式类型转换」-也就是自动类型转换–-gt-具体表现为一个变量声明类型后后序可以用其他类型覆盖-来分类，可以分为强类型和弱类型：" class="headerlink" title="区分弱类型和强类型：类型系统按照「是否允许隐式类型转换」(也就是自动类型转换–&gt;具体表现为一个变量声明类型后后序可以用其他类型覆盖)来分类，可以分为强类型和弱类型："></a>区分弱类型和强类型：类型系统按照「是否允许隐式类型转换」(也就是自动类型转换–&gt;具体表现为一个变量声明类型后后序可以用其他类型覆盖)来分类，可以分为强类型和弱类型：</h4><h4 id="javascript和Typescript允许隐式类型转换，所以是弱语言"><a href="#javascript和Typescript允许隐式类型转换，所以是弱语言" class="headerlink" title="javascript和Typescript允许隐式类型转换，所以是弱语言"></a>javascript和Typescript允许隐式类型转换，所以是弱语言</h4><h4 id="python不允许隐式类型转换，所以是强"><a href="#python不允许隐式类型转换，所以是强" class="headerlink" title="python不允许隐式类型转换，所以是强"></a>python不允许隐式类型转换，所以是强</h4><h2 id="13"><a href="#13" class="headerlink" title="13."></a>13.</h2><h4 id="Coinbase交易既是创币交易"><a href="#Coinbase交易既是创币交易" class="headerlink" title="Coinbase交易既是创币交易"></a>Coinbase交易既是创币交易</h4><h2 id="14"><a href="#14" class="headerlink" title="14."></a>14.</h2><h4 id="比特币单位换算关系如下："><a href="#比特币单位换算关系如下：" class="headerlink" title="比特币单位换算关系如下："></a>比特币单位换算关系如下：</h4><h4 id="1比特币（Bitcoins，BTC）"><a href="#1比特币（Bitcoins，BTC）" class="headerlink" title="1比特币（Bitcoins，BTC）"></a>1比特币（Bitcoins，BTC）</h4><h4 id="0-01比特分（Bitcent，cBTC）"><a href="#0-01比特分（Bitcent，cBTC）" class="headerlink" title="0.01比特分（Bitcent，cBTC）"></a>0.01比特分（Bitcent，cBTC）</h4><h4 id="0-001毫比特（Milli-Bitcoins，mBTC）"><a href="#0-001毫比特（Milli-Bitcoins，mBTC）" class="headerlink" title="0.001毫比特（Milli-Bitcoins，mBTC）"></a>0.001毫比特（Milli-Bitcoins，mBTC）</h4><h4 id="0-000001微比特（Micro-Bitcoins，μBTC或uBTC）"><a href="#0-000001微比特（Micro-Bitcoins，μBTC或uBTC）" class="headerlink" title="0.000001微比特（Micro-Bitcoins，μBTC或uBTC）"></a>0.000001微比特（Micro-Bitcoins，μBTC或uBTC）</h4><h4 id="0-00000001聪（satoshi）（基本单位）"><a href="#0-00000001聪（satoshi）（基本单位）" class="headerlink" title="0.00000001聪（satoshi）（基本单位）"></a>0.00000001聪（satoshi）（基本单位）</h4><h4 id="1-bitcoin-BTC-x3D-1000-millibitcoins-mBTC-x3D-1-million-microbitcoins-uBTC-x3D-100-million-Satoshi"><a href="#1-bitcoin-BTC-x3D-1000-millibitcoins-mBTC-x3D-1-million-microbitcoins-uBTC-x3D-100-million-Satoshi" class="headerlink" title="1 bitcoin (BTC) &#x3D; 1000 millibitcoins (mBTC) &#x3D; 1 million microbitcoins (uBTC) &#x3D; 100 million Satoshi"></a>1 bitcoin (BTC) &#x3D; 1000 millibitcoins (mBTC) &#x3D; 1 million microbitcoins (uBTC) &#x3D; 100 million Satoshi</h4><h2 id="15"><a href="#15" class="headerlink" title="15."></a>15.</h2><h4 id="gasprice-x3D-baseFee-TipbaseFee是基本费用，由协议根据区块大小自动计算Tip就是小费，或者书面一点，称之为优先费用（PriorityFee）（矿工只能拿到这部分）"><a href="#gasprice-x3D-baseFee-TipbaseFee是基本费用，由协议根据区块大小自动计算Tip就是小费，或者书面一点，称之为优先费用（PriorityFee）（矿工只能拿到这部分）" class="headerlink" title="gasprice &#x3D;baseFee+ TipbaseFee是基本费用，由协议根据区块大小自动计算Tip就是小费，或者书面一点，称之为优先费用（PriorityFee）（矿工只能拿到这部分）"></a>gasprice &#x3D;baseFee+ TipbaseFee是基本费用，由协议根据区块大小自动计算Tip就是小费，或者书面一点，称之为优先费用（PriorityFee）（矿工只能拿到这部分）</h4><h2 id="16"><a href="#16" class="headerlink" title="16."></a>16.</h2><h4 id="智能合约就是一组规则和规则指导下的数据的合体。相当于一个后端代码-数据库"><a href="#智能合约就是一组规则和规则指导下的数据的合体。相当于一个后端代码-数据库" class="headerlink" title="智能合约就是一组规则和规则指导下的数据的合体。相当于一个后端代码+数据库"></a>智能合约就是一组规则和规则指导下的数据的合体。相当于一个后端代码+数据库</h4><h2 id="17"><a href="#17" class="headerlink" title="17."></a>17.</h2><h4 id="以太坊两个账户的概念相当于现实生活中的两个人–一个是你自己，另一个是跟随你的管家"><a href="#以太坊两个账户的概念相当于现实生活中的两个人–一个是你自己，另一个是跟随你的管家" class="headerlink" title="以太坊两个账户的概念相当于现实生活中的两个人–一个是你自己，另一个是跟随你的管家"></a>以太坊两个账户的概念相当于现实生活中的两个人–一个是你自己，另一个是跟随你的管家</h4><h2 id="18"><a href="#18" class="headerlink" title="18."></a>18.</h2><h4 id="以太坊的交易就是一次消息传递，传递的是-数据-以及-价值-以太币"><a href="#以太坊的交易就是一次消息传递，传递的是-数据-以及-价值-以太币" class="headerlink" title="以太坊的交易就是一次消息传递，传递的是 数据 以及 价值 (以太币)"></a>以太坊的交易就是一次消息传递，传递的是 数据 以及 价值 (以太币)</h4><h4 id="区别仅仅在于交易体中是否携带数据。"><a href="#区别仅仅在于交易体中是否携带数据。" class="headerlink" title="区别仅仅在于交易体中是否携带数据。"></a>区别仅仅在于交易体中是否携带数据。</h4><h4 id="携带数据的交易可能是一个次智能合约调用；"><a href="#携带数据的交易可能是一个次智能合约调用；" class="headerlink" title="携带数据的交易可能是一个次智能合约调用；"></a>携带数据的交易可能是一个次智能合约调用；</h4><h4 id="不携带数据的就是一次普通以太币转账。"><a href="#不携带数据的就是一次普通以太币转账。" class="headerlink" title="不携带数据的就是一次普通以太币转账。"></a>不携带数据的就是一次普通以太币转账。</h4><h4 id="智能合约具备接收数据，处理数据的能力。"><a href="#智能合约具备接收数据，处理数据的能力。" class="headerlink" title="智能合约具备接收数据，处理数据的能力。"></a>智能合约具备接收数据，处理数据的能力。</h4><h2 id="19"><a href="#19" class="headerlink" title="19."></a>19.</h2><h4 id="solidaty函数的接收参数一般会加上”-”符号，是为了区别于全局变量，调用的时候直接采用传入方式调用"><a href="#solidaty函数的接收参数一般会加上”-”符号，是为了区别于全局变量，调用的时候直接采用传入方式调用" class="headerlink" title="solidaty函数的接收参数一般会加上”_”符号，是为了区别于全局变量，调用的时候直接采用传入方式调用"></a>solidaty函数的接收参数一般会加上”_”符号，是为了区别于全局变量，调用的时候直接采用传入方式调用</h4><h2 id="20"><a href="#20" class="headerlink" title="20."></a>20.</h2><h4 id="以太坊的输入输出很简单，没有将像普通的计算机一样有键盘，网络等输入，也没有显示器，打印机等输出；输入输出都只有两类来源："><a href="#以太坊的输入输出很简单，没有将像普通的计算机一样有键盘，网络等输入，也没有显示器，打印机等输出；输入输出都只有两类来源：" class="headerlink" title="以太坊的输入输出很简单，没有将像普通的计算机一样有键盘，网络等输入，也没有显示器，打印机等输出；输入输出都只有两类来源："></a>以太坊的输入输出很简单，没有将像普通的计算机一样有键盘，网络等输入，也没有显示器，打印机等输出；输入输出都只有两类来源：</h4><h4 id="输入："><a href="#输入：" class="headerlink" title="输入："></a>输入：</h4><h4 id="·另一个以太坊虚拟机传来的函数调用所携带的数据"><a href="#·另一个以太坊虚拟机传来的函数调用所携带的数据" class="headerlink" title="·另一个以太坊虚拟机传来的函数调用所携带的数据"></a>·另一个以太坊虚拟机传来的函数调用所携带的数据</h4><h4 id="·外部账户调用合约账户，所携带的交易数据"><a href="#·外部账户调用合约账户，所携带的交易数据" class="headerlink" title="·外部账户调用合约账户，所携带的交易数据"></a>·外部账户调用合约账户，所携带的交易数据</h4><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><h4 id="·运行过程中修改的区块链账户的存储区"><a href="#·运行过程中修改的区块链账户的存储区" class="headerlink" title="·运行过程中修改的区块链账户的存储区"></a>·运行过程中修改的区块链账户的存储区</h4><h4 id="·日志"><a href="#·日志" class="headerlink" title="·日志"></a>·日志</h4><h2 id="21"><a href="#21" class="headerlink" title="21."></a>21.</h2><h4 id="区块链是一种“具有共享状态的加密安全交易单例机器"><a href="#区块链是一种“具有共享状态的加密安全交易单例机器" class="headerlink" title="区块链是一种“具有共享状态的加密安全交易单例机器"></a>区块链是一种“具有共享状态的加密安全交易单例机器</h4><h2 id="22"><a href="#22" class="headerlink" title="22."></a>22.</h2><h4 id="以太坊节点类型有三种：全节点，轻节点，归档节点"><a href="#以太坊节点类型有三种：全节点，轻节点，归档节点" class="headerlink" title="以太坊节点类型有三种：全节点，轻节点，归档节点"></a>以太坊节点类型有三种：全节点，轻节点，归档节点</h4><h2 id="23"><a href="#23" class="headerlink" title="23."></a>23.</h2><h4 id="solidaty和js不同的是，solidaty的变量值都有默认值，而js如果只声明类型而不初始化值会是undefine"><a href="#solidaty和js不同的是，solidaty的变量值都有默认值，而js如果只声明类型而不初始化值会是undefine" class="headerlink" title="solidaty和js不同的是，solidaty的变量值都有默认值，而js如果只声明类型而不初始化值会是undefine"></a>solidaty和js不同的是，solidaty的变量值都有默认值，而js如果只声明类型而不初始化值会是undefine</h4><h2 id="24"><a href="#24" class="headerlink" title="24."></a>24.</h2><h4 id="当使用-npm-安装软件包时，可以执行两种安装类型：本地安装，全局安装-查看系统全局安装地址：npm-root-g"><a href="#当使用-npm-安装软件包时，可以执行两种安装类型：本地安装，全局安装-查看系统全局安装地址：npm-root-g" class="headerlink" title="当使用 npm 安装软件包时，可以执行两种安装类型：本地安装，全局安装(查看系统全局安装地址：npm root -g)"></a>当使用 npm 安装软件包时，可以执行两种安装类型：本地安装，全局安装(查看系统全局安装地址：npm root -g)</h4><h2 id="25"><a href="#25" class="headerlink" title="25."></a>25.</h2><h4 id="在solidaty中，一个工厂-x3D-一个合约-x3D-多个合约对象"><a href="#在solidaty中，一个工厂-x3D-一个合约-x3D-多个合约对象" class="headerlink" title="在solidaty中，一个工厂&#x3D;一个合约&#x3D;多个合约对象"></a>在solidaty中，一个工厂&#x3D;一个合约&#x3D;多个合约对象</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javaScript异步操作学习</title>
      <link href="/hexoblog.github.io/2022/09/22/javascript%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/"/>
      <url>/hexoblog.github.io/2022/09/22/javascript%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="javascript的单线程理解"><a href="#javascript的单线程理解" class="headerlink" title="javascript的单线程理解:"></a>javascript的单线程理解:</h2><ol><li>首先来说javascript是基于浏览器的，也被叫做浏览器语言，而浏览器是多线程内核的，一般有以下常驻线程：</li></ol><ul><li>渲染引擎线程：该线程负责渲染浏览器页面</li><li>JS引擎线程：该线程负责JS的解析和执行</li><li>定时触发器线程：处理定时事件，比如setTimeout，setInterval</li><li>事件触发线程：处理DOM事件</li><li>异步http请求线程：处理http请求</li><li>注意：渲染线程和JS引擎线程不能同时进行</li></ul><ol start="2"><li><p>JS引擎线程负责JS，负责JS代码的解析和执行，而Javascript之所以是单线程是因为浏览器在运行的时候之开启了一个JS引擎线程来解析和执行JS。</p></li><li><p>所以我们应该知道的是因为为了避免操作DOM时产生混乱，浏览器只会开启一个JS引擎线程，而与I&#x2F;O操作、定时器的计时和事件监听…等都是由浏览器提供的其他线程完成的。</p></li></ol><h2 id="同步Synchronous与异步Asynchronous："><a href="#同步Synchronous与异步Asynchronous：" class="headerlink" title="同步Synchronous与异步Asynchronous："></a>同步<code>Synchronous</code>与异步<code>Asynchronous</code>：</h2><p>引用一个例子理解同步和异步的关系：在公路上，汽车一辆接一辆，有条不紊的在<strong>a:一条主道路上单向运行</strong>。这时，有<strong>b:一辆车</strong>坏掉了。假如它停在原地进行修理，那么后面的车就会被堵住没法行驶，交通就乱套了。幸好旁边有<strong>c:应急车道</strong>，可以把<strong>d:故障车辆</strong>推到应急车道<strong>e:修理</strong>，而正常的车流不会受到任何影响。等车修好了，再<strong>f:从应急车道回到正常车道</strong>即可。唯一的影响就是，应急车道用多了，原来的车辆之间的顺序会有点乱</p><h4 id="理解："><a href="#理解：" class="headerlink" title="理解："></a>理解：</h4><ul><li><pre><code>  a:js引擎的主线程; </code></pre></li><li><pre><code>  b:主线程当中执行的一个同步任务; </code></pre></li><li><pre><code>  c:任务队列(不在主线程); </code></pre></li><li><pre><code>  d:一个异步任务; </code></pre></li><li><pre><code>  e:将一个异步任务放入消息队列;</code></pre></li><li><pre><code>  f:异步任务需等待主线程栈中所有任务执行完后，由事件循环机制将一个异步任务放进主线程</code></pre></li></ul><h2 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h2><ul><li><p>任务队列(消息队列) 是一个先进先出的<strong>队列</strong>，它里面存放着各种消息–&gt;回调函数可以是一个消息</p></li><li><p>事件循环 是指主线程重复从消息队列中取出消息然后执行的循环执行机制,即基于Event LOOP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">什么是Event LOOP：</span><br><span class="line">https://www.ruanyifeng.com/blog/2013/10/event_loop.html</span><br></pre></td></tr></table></figure></li></ul><h2 id="理解一些异步操作-异步编程"><a href="#理解一些异步操作-异步编程" class="headerlink" title="理解一些异步操作(异步编程)"></a>理解一些异步操作(异步编程)</h2><p>我们已经知道javascript是单线程执行任务，即后一个任务必须等待前一个任务的完成，但是我们必须这样吗?考虑到效率就需要一些异步操作，即可以实现将一些耗时的任务比如等待文件的读取挂起来(进入任务队列)，再进行下一个任务的执行，知道文件的读取有了结果或者响应后，再回过头执行任务队列的任务。</p><h2 id="有以下几种方式可以实现异步编程："><a href="#有以下几种方式可以实现异步编程：" class="headerlink" title="有以下几种方式可以实现异步编程："></a>有以下几种方式可以实现异步编程：</h2><ul><li>回调函数</li><li>事件监听</li><li>发布&#x2F;订阅</li><li>promise</li><li>generator（ES6）</li><li>async&#x2F;await(ES7)</li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数是实现异步最简单的操作和最基本的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.异步操作前：</span><br><span class="line">function fn1 () &#123;</span><br><span class="line">  console.log(&#x27;Function 1&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2 () &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Function 2&#x27;)</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn3 () &#123;</span><br><span class="line">  console.log(&#x27;Function 3&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line">fn2();</span><br><span class="line">fn3();</span><br></pre></td></tr></table></figure><p>上面的代码意图是顺序执行fn1、fn2和fn3函数</p><p>但是如果fn2可以视作一个延迟了500毫秒执行的异步函数，也就是说fn2的函数会被挂起而进入任务队列等待后面fn3函数执行完毕后fn2再执行</p><p>所以我们想要保持原来的意图，即fn1执行后然后执行fn2再执行fn3的这个顺序，于是我们这儿可以使用回调函数解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//使用回调函数改变代码结构</span><br><span class="line">function fn2 (f) &#123;</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Function 2&#x27;)</span><br><span class="line">    f()</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line">fn2(fn3);</span><br><span class="line">//上面这段代码是回调函数的基本用法：将一个任务的函数名作为参数传入另一个任务，这个作为作为参数的函数名的函数就是回调函数</span><br></pre></td></tr></table></figure><p>这样就达到了最初的意图-fn1，fn2，fn3依次执行</p><p>但是fn2和fn3完全耦合在一起，如果有多个类似的函数，很有可能出现fn1(fn2(fn3(fn4(…))))这样的情况，这就是<code>回调地狱</code>(多个回调函数嵌套的情况)。</p><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul><li><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口，也就是为解决回调函数噩梦而提出的写法–&gt;将回调函数的横向加载变成纵向加载。</p></li><li><p>首先来说Promise是一个对象，也是一个构造函数</p></li><li><p>理解Promise机制：Promise是一个代理对象，这个值可以称为Promise对象的状态，而Promise对象就是通过自身的状态来控制异步函数–&gt;Promise实例具有三种状态(PromiseStatus)：</p><ul><li>异步操作未完成(pending)： promise暂时还没有被解决也没有被拒绝，仍然处于pending状态</li><li>异步操作成功(fulfilled)：promise已经被resolved没有发生错误</li><li>异步操作失败(rejected)：promise已经被rejected，出现错误</li></ul></li></ul><p><strong>我们可以通过一个new一个Promise：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//通常我们是通过new一个Primise对象，然后传入一个函数(这里是匿名函数)</span><br><span class="line">//(其中入参resolve和reject都是改变状态的函数，由javascript引擎实现)</span><br><span class="line">var promise = new Promise(function(resolve,reject)&#123;//刚定义时状态默认为pending</span><br><span class="line"></span><br><span class="line">//需要异步执行的代码...</span><br><span class="line"></span><br><span class="line"> if (/* 异步操作成功 */)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123; /* 异步操作失败 */</span><br><span class="line">    reject(new Error());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//注意四点：</span><br><span class="line">  //1.执行resolve函数会将状态改为fulfilled:  </span><br><span class="line">    //resolve(retValue):retValue可以是任何值，null也可以，它会传递给后面的then方法里面的function去使用</span><br><span class="line"></span><br><span class="line">  //2.执行reject函数会将状态改为rejected:</span><br><span class="line">    //通过rejected（err）传入的err理论上也是没有限制类型的，但是一般会传入一个错误</span><br><span class="line"></span><br><span class="line">  //3.状态改变是持久的，可以查询到，并且状态变化后可以影响后续的then的行为</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对于一个promise-我们可以使用它上面的三个方法："><a href="#对于一个promise-我们可以使用它上面的三个方法：" class="headerlink" title="对于一个promise, 我们可以使用它上面的三个方法："></a>对于一个promise, 我们可以使用它上面的三个方法：</h3><ol><li><p>·then(): 在一个promise被resolved后调用，内部有两个方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise.then(function onFulfilled(value)&#123; console.log(value);//return undefined &#125;,</span><br><span class="line">            function onRejected(error)&#123; console.error(error);//return undefined&#125;)</span><br><span class="line"></span><br><span class="line">//我们在使用.then多次调用形成一个调用链时，比如：promise.then(step2).then(step3)....then(stepn)。每个then返回的都必须是一个promise对象，假如then方法里面的onFulfilled函数返回的不是promise，比如是Number或string，那么架构会用Promise.resolve(return的返回值)包装成一个resolved状态的promise返回</span><br><span class="line"></span><br><span class="line">//一般只会使用resolve，也就是只在传入一个then中传入一个匿名函数</span><br></pre></td></tr></table></figure></li><li><p>.catch(): 在一个promise被rejected后被调用</p></li><li><p>.finally(): 不论promise是被resolved还是reject总是调用</p></li></ol><p><strong>用法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//1.以加载图片压缩图片、为图片应用过滤器并保存它的例子说明：</span><br><span class="line"></span><br><span class="line">//定义函数</span><br><span class="line">function getImage(file) &#123;</span><br><span class="line">  return new Promise((res, rej) =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const data = readFile(file)</span><br><span class="line">      res(data) // 如果图片加载完成且一切正常，用加载完的图片解决(resolve)promise</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">      rej(new Error(err)) // 果在加载文件时某个地方有一个错误，我们将会用发生的错误拒绝(reject)promise</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">//调用：</span><br><span class="line">getImage(file)</span><br><span class="line">  .then(image =&gt; console.log(image))</span><br><span class="line">  .then(compressedImage =&gt; applyFilter(compressedImage)) // 添加滤镜</span><br><span class="line">  .then(filteredImage =&gt; saveImage(filteredImage))// 保存图片</span><br><span class="line">  .catch(error =&gt; console.log(error))//</span><br><span class="line">  .finally(() =&gt; console.log(&quot;All done!&quot;))</span><br><span class="line"></span><br><span class="line">//2.注意：</span><br><span class="line">  //通常在.then步骤结束后添s加一个catch()函数依次捕捉每一个then方法可能出现的rejectd返回值</span><br></pre></td></tr></table></figure><h2 id="“微任务”"><a href="#“微任务”" class="headerlink" title="“微任务”:"></a>“微任务”:</h2><p>Promise 的回调函数属于异步任务，准确来说是不正常的异步任务(微任务)，执行顺序在同步任务和正常异步任务之间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(2);</span><br><span class="line">&#125;).then(console.log);</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line">// 3</span><br><span class="line">// 2</span><br><span class="line">// 1</span><br></pre></td></tr></table></figure><h2 id="Async-x2F-Await"><a href="#Async-x2F-Await" class="headerlink" title="Async&#x2F;Await"></a>Async&#x2F;Await</h2><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>异步操作概述：<br><a href="https://wangdoc.com/javascript/async/general.html">https://wangdoc.com/javascript/async/general.html</a></p><p>js中的异步与同步:<br><a href="https://www.cnblogs.com/Yellow-ice/p/10433423.html">https://www.cnblogs.com/Yellow-ice/p/10433423.html</a></p><p>JavaScript异步机制详解:<br><a href="https://blog.csdn.net/LRH0211/article/details/79172822">https://blog.csdn.net/LRH0211/article/details/79172822</a></p><p>JavaScript Promise 和Async&#x2F;Await一看就懂:<br><a href="https://blog.csdn.net/qq_36174666/article/details/106353457">https://blog.csdn.net/qq_36174666/article/details/106353457</a></p><p>js异步操作、事件监听、发布-订阅模式、Generator函数:<br><a href="https://zhuanlan.zhihu.com/p/67629425">https://zhuanlan.zhihu.com/p/67629425</a></p><p>浅析js中的Promise和async&#x2F;await:<br><a href="https://blog.csdn.net/yes1983/article/details/83629647">https://blog.csdn.net/yes1983/article/details/83629647</a></p>]]></content>
      
      
      <categories>
          
          <category> javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>solidaty中函数的可见性和修饰符</title>
      <link href="/hexoblog.github.io/2022/09/21/solidaty%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/hexoblog.github.io/2022/09/21/solidaty%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="前言：Solidity-语言是一种专门用于编写和执行智能合约的语言"><a href="#前言：Solidity-语言是一种专门用于编写和执行智能合约的语言" class="headerlink" title="前言：Solidity 语言是一种专门用于编写和执行智能合约的语言:"></a>前言：Solidity 语言是一种专门用于编写和执行智能合约的语言:</h1><p>它是在以太坊虚拟机基础上运行的、面向合约的高级语言，最初是在 2014 年 8 月由以太坊的前任 CTO和联合创始人 Gavin Wood 提出来的，后来由以太坊开发人员组建了一支专门的团队，对 Solidity 语言进行不断改进，目前仍在开发和优化之中…..</p><h2 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h2><h3 id="函数是以太坊实现各种逻辑的基础，在solidaty中，函数的语法定义如下："><a href="#函数是以太坊实现各种逻辑的基础，在solidaty中，函数的语法定义如下：" class="headerlink" title="函数是以太坊实现各种逻辑的基础，在solidaty中，函数的语法定义如下："></a>函数是以太坊实现各种逻辑的基础，在solidaty中，函数的语法定义如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function + 函数的名字+(传递给函数的参数，包括参数的名称和类型) +函数可见性+函数修饰符 +returns (返回的类型，若有多个，以逗号分隔)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>是不是类似于javascript，并且也可以看出区别就是相应的函数可见性和和函数修饰符还有的就是solidaty支持go语言般的可以返回多个值，对于函数可见性和修饰符的学习我觉得可以进一步加深对智能合约的理解</p><h2 id="函数可见性：internal、private、external、public-用于设定函数的可见范围："><a href="#函数可见性：internal、private、external、public-用于设定函数的可见范围：" class="headerlink" title="函数可见性：internal、private、external、public:用于设定函数的可见范围："></a>函数可见性：internal、private、external、public:用于设定函数的可见范围：</h2><h3 id="对于public和private来说，学过Java的都知道能够明白："><a href="#对于public和private来说，学过Java的都知道能够明白：" class="headerlink" title="对于public和private来说，学过Java的都知道能够明白："></a>对于public和private来说，学过Java的都知道能够明白：</h3><ul><li>public：可以用来修饰变量和函数，所修饰的变量和函数，任何用户都能调用和访问,public 是默认值</li><li>private：可以用来修饰变量和函数，所修饰的变量和函数，只能在其所在的合约中调用和访问，即使是其子合约也没有权限访问<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//public修饰变量</span><br><span class="line">uint public num1;</span><br><span class="line"></span><br><span class="line">//private修饰变量</span><br><span class="line">uint private num2;</span><br><span class="line"></span><br><span class="line">//public修饰函数</span><br><span class="line">function myFirstHelloWorld01() public &#123;&#125;</span><br><span class="line"></span><br><span class="line">//private修饰函数</span><br><span class="line">function myFirstHelloWorld02() private &#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="external和internal："><a href="#external和internal：" class="headerlink" title="external和internal："></a>external和internal：</h3><ul><li><p>external：和public类似，但只用来修饰函数，并且被修饰的函数仅支持外部调用，不能在合约内部的其他函数调用</p></li><li><p>internal：和private类似，但只用来修饰函数，并且internal 函数只能被合约内部的函数调用；不过，如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的“内部”函数。</p></li></ul><p><strong>注意：internal、private、external、public这4种关键字都是可见性修饰符，互不共存</strong></p><h3 id="通过一个例子加深可视化的理解："><a href="#通过一个例子加深可视化的理解：" class="headerlink" title="通过一个例子加深可视化的理解："></a>通过一个例子加深可视化的理解：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">有一个A合约，它有一些可视化的函数：</span><br><span class="line">-----------------</span><br><span class="line">A</span><br><span class="line">private pri()</span><br><span class="line">internal inner()</span><br><span class="line">public pub()</span><br><span class="line">external ext()</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">然后有一个B，合约它继承A合约：继承合约只能看到父合约中的被internal和public修饰的函数：</span><br><span class="line">-----------------</span><br><span class="line">B is A</span><br><span class="line">internal inter()</span><br><span class="line">public pub()</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">最后有一个C合约调用A合约：那么C合约只能看到A合约中的被public和external修饰的函数:</span><br><span class="line">-----------------</span><br><span class="line">C</span><br><span class="line">public pub()</span><br><span class="line">external ext()</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><h2 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符:"></a>函数修饰符:</h2><p>view&#x2F;constant、pure、payable、modifier:影响函数的行为</p><h3 id="view-视图函数-x2F-constant"><a href="#view-视图函数-x2F-constant" class="headerlink" title="view(视图函数)&#x2F;constant"></a>view(视图函数)&#x2F;constant</h3><p>被view修饰的函数不能修改状:态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//定义一个状态变量：</span><br><span class="line">uint public num1;</span><br><span class="line"></span><br><span class="line">//这个函数应该用view来修饰,读取了状态变量，但保证不修改状态</span><br><span class="line">    function addToNum1(uint x) external view returns (uint)&#123;</span><br><span class="line">        return num1 + x;</span><br></pre></td></tr></table></figure><h3 id="pure-纯函数"><a href="#pure-纯函数" class="headerlink" title="pure(纯函数)"></a>pure(纯函数)</h3><p>被pure修饰的函数既不修改状态也不读取状态:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//定义一个状态变量：</span><br><span class="line">uint public num1;</span><br><span class="line"></span><br><span class="line">//这个函数应该用pure来修饰,既没有修改状态也没有读取状态</span><br><span class="line">    function addToNum2(uint x,uint y) external pure returns (uint)&#123;</span><br><span class="line">        return x + y;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="下面的语句被认为是在修改状态："><a href="#下面的语句被认为是在修改状态：" class="headerlink" title="下面的语句被认为是在修改状态："></a>下面的语句被认为是在修改状态：</h3><ul><li>修改状态变量；</li><li>触发事件；</li><li>创建其他合约；</li><li>使用 selfdestruct；</li><li>通过调用发送以太币；</li><li>调用任何未标记 view 或 pure 的函数；</li><li>使用低级调用；</li><li>使用包含某些操作码的内联汇编。</li></ul><h3 id="payable："><a href="#payable：" class="headerlink" title="payable："></a>payable：</h3><p>payable修饰的函数用于接受外部的支付，它们是一种可以接收以太的特殊函数;当一个函数呗payable修饰，表示调用这个函数时，可以附加发送一些ETH(也可以不发)，但是没有加payable的函数，附加ETH调用会报错</p><h3 id="modifier："><a href="#modifier：" class="headerlink" title="modifier："></a>modifier：</h3><p>修改器(Modifiers)可以用来轻易的改变一个函数的行为。比如用于在函数执行前检查某种前置条件。修改器是一种合约属性，可被继承，同时还可被派生的合约重写(override)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.8.15;</span><br><span class="line"></span><br><span class="line">//修饰器modifier 可以轻松改变函数的行为</span><br><span class="line">//比如用于在函数执行前检查某种前置条件</span><br><span class="line"></span><br><span class="line">//具体用法：</span><br><span class="line">contract modifierFun&#123;</span><br><span class="line">    //1.先定义一个状态变量</span><br><span class="line">    uint public a;</span><br><span class="line">   </span><br><span class="line">    //2.然后我们定义一个修饰器，修饰器可以接收变量</span><br><span class="line">      //格式：modifier 修饰器名字(接收变量类型 接收变量,接收变量类型 接收变量...)&#123;修饰器逻辑; _;&#125;</span><br><span class="line">    modifier modifierfun(uint value)&#123;</span><br><span class="line">        require(value &gt;= 10);//require函数</span><br><span class="line">        _;//修饰器当中的&quot;_&quot;符号代表所修饰函数中的代码。</span><br><span class="line">        a+=1;//上面&quot;_&quot;代表的函数代码执行完后会返回来执行完modifier当中的剩余代码</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //3.定义一个被modifier修饰的函数</span><br><span class="line">      //如果执行这个函数，需要先执行修饰器当中的代码，然后再执行函数中的代码</span><br><span class="line">    function setValue(uint num) external modifierfun(num)&#123;</span><br><span class="line">        a = num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //4.定义一个函数，返回设置的状态变量</span><br><span class="line">    function getValue() external view returns (uint)&#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //5.多重modifier:</span><br><span class="line"></span><br><span class="line">    uint public b = 0;</span><br><span class="line">   </span><br><span class="line">    modifier mod&#123;</span><br><span class="line">        b = 1;</span><br><span class="line">        _;</span><br><span class="line">        b = 5;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">     modifier mod1&#123;</span><br><span class="line">        b = 3;</span><br><span class="line">        _;</span><br><span class="line">        b = 4;</span><br><span class="line">     &#125;</span><br><span class="line">   </span><br><span class="line">    //格式:再修饰符的位置添上n个modifier嵌套</span><br><span class="line">    function test() public mod mod1&#123;</span><br><span class="line">        b = 100;</span><br><span class="line">    &#125;</span><br><span class="line">    //上面是两个modifier修饰的函数,执行顺序为b=1 ---&gt; b=3 ----&gt; b=100 ----&gt; b=4 ----&gt; b=5</span><br><span class="line">      //分析:首先执行mod中的&quot;b = 1&quot;的代码,因为这是modifier多重嵌套,下一行的&quot;_&quot;执行的是下一层也就是例子当中mod1中的代码,</span><br><span class="line">      //而执行到mod1中&quot;_&quot;的时候,这个时候已经没有下一层的嵌套了,于是执行函数体中的代码,函数体中的代码执行完后,便像压栈似的返回执行剩余未执行的代码</span><br><span class="line">      </span><br><span class="line">      //理解:执行过程类似压栈,而modifier修饰器相当于一个特殊的函数</span><br><span class="line"></span><br><span class="line">    //6.总结：修饰器其实类似于一个过滤器(通常也也是过滤器的作用，比如限制只有某些地址的账户才能调用该函数--&gt;通常与require函数搭配)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h3><p><a href="https://blog.csdn.net/qq_33829547/article/details/80460013">https://blog.csdn.net/qq_33829547/article/details/80460013</a></p><p><a href="https://blog.csdn.net/HDUCheater/article/details/113312162">https://blog.csdn.net/HDUCheater/article/details/113312162</a></p><p><a href="https://blog.csdn.net/wyf2017/article/details/108463485">https://blog.csdn.net/wyf2017/article/details/108463485</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 以太坊 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript属性描述对象整理</title>
      <link href="/hexoblog.github.io/2022/09/18/javaScript%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1%E6%95%B4%E7%90%86/"/>
      <url>/hexoblog.github.io/2022/09/18/javaScript%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="概述以及定义："><a href="#概述以及定义：" class="headerlink" title="概述以及定义："></a>概述以及定义：</h2><ul><li>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。</li><li>这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</li></ul><h3 id="属性描述对象有以下六个元属性-一个代码块-来描述对象的属性"><a href="#属性描述对象有以下六个元属性-一个代码块-来描述对象的属性" class="headerlink" title="属性描述对象有以下六个元属性(一个代码块)来描述对象的属性:"></a>属性描述对象有以下六个元属性(一个代码块)来描述对象的属性:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    writable:fasel,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: false,</span><br><span class="line">    get: undefined,</span><br><span class="line">    set: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改属性描述符"><a href="#修改属性描述符" class="headerlink" title="修改属性描述符"></a>修改属性描述符</h2><ol><li><p><code>value</code>:该属性的属性值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;//声明一个空对象</span><br><span class="line">obj.p = 123;//声明obj的一个属性p</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(obj, &#x27;p&#x27;).value;//通过Object.getOwnPropertyDescriptor()函数获取</span><br><span class="line">//123</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&#x27;p&#x27;,&#123;value:456&#125;);//通过Object.defineProperty()对属性value进行修改</span><br><span class="line">//456</span><br></pre></td></tr></table></figure></li><li><p><code>writable</code>：布尔值，决定该属性是否可改变，默认true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj,&#x27;a&#x27;,&#123;</span><br><span class="line">    value: 37,</span><br><span class="line">    writable: false,//修改该属性对象描述中的writable为不可修改</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.a//37</span><br><span class="line">obj.a = 23;</span><br><span class="line">//1.正常模式下上一行代码修改对象属性描述对象的writable值为false的操作不会报错，但是严格模式下任何赋值行为都会报错</span><br><span class="line">//2.接第一点如果，因为子对象继承该父对象，子对象将无法自定义这个属性，也就是说，在严格模式下，父对象定义好了writable的值而子对象修改writable的值会报错</span><br><span class="line">//3.接上面两点，有一个规避方法，就是通过覆盖属性描述对象</span><br><span class="line"></span><br><span class="line">obj.a//无法被修改，所以仍然为37</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><code>enumerable</code>:布尔值，表示该属性是否可遍历，默认为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &#x27;x&#x27;, &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  enumerable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.x // 123</span><br><span class="line"></span><br><span class="line">for (var key in obj) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">// undefined </span><br><span class="line"></span><br><span class="line">//enumerable为false，下面三个操作不会取到该属性。</span><br><span class="line"></span><br><span class="line">for..in循环(for...in循环包括继承的属性)</span><br><span class="line">Object.keys方法(Object.keys方法不包括继承的属性)</span><br><span class="line">JSON.stringify方法</span><br></pre></td></tr></table></figure></li><li><p><code>configurable</code>:布尔值，表示该属性是否可遍历，默认为true,设置为false会使得某些操作(for..in…或者Object.keys())跳过该属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//1.如果对象的属性描述对象中的configurable属性被设为了false值，那么相关的这个对象中的configurable为false时，writable、enumerable和configurable都不能被修改了。(浅不变性)</span><br><span class="line"></span><br><span class="line">//2.value属性的情况比较特殊。只要writable和configurable有一个为true，就允许改动value</span><br><span class="line"></span><br><span class="line">var obj = Object.defineProperty(&#123;&#125;, &#x27;p&#x27;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  writable: false,</span><br><span class="line">  enumerable: false,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &#x27;p&#x27;, &#123;writable: true&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line">//3.writable属性只有在false改为true时会报错，true改为false是允许的。</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &#x27;p&#x27;, &#123;enumerable: true&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &#x27;p&#x27;, &#123;configurable: true&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line"></span><br><span class="line">Object.defineProperty(obj, &#x27;p&#x27;, &#123;value: 2&#125;)</span><br><span class="line">// TypeError: Cannot redefine property: p</span><br><span class="line"></span><br><span class="line">//4.并且可配置性决定了目标属性是否可以被删除（delete），configurable是true，就可以被删除，否则就不行</span><br></pre></td></tr></table></figure></li></ol><h2 id="对象常量"><a href="#对象常量" class="headerlink" title="对象常量"></a>对象常量</h2><p>也就是说，上面&#x2F;&#x2F;1.的<code>obj.p</code>属性设置成<code>writable:false,configurable:false</code>后，这个对象的这个属性就变成了常量，不可修改，不可删除，不可定义</p><ol start="5"><li>存取器：<code>get</code>:是一个函数，表示该属性的取值函数(getter)，默认为undefined<h2 id="set-是一个函数，表示该函数的存值函数-setter-默认为undefined"><a href="#set-是一个函数，表示该函数的存值函数-setter-默认为undefined" class="headerlink" title="set:是一个函数，表示该函数的存值函数(setter),默认为undefined"></a><code>set</code>:是一个函数，表示该函数的存值函数(setter),默认为undefined</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var obj = Object.defineProperty(&#123;&#125;, &#x27;p&#x27;, &#123;</span><br><span class="line">  get: function () &#123;</span><br><span class="line">    return &#x27;getter&#x27;;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: function (value) &#123;</span><br><span class="line">    console.log(&#x27;setter: &#x27; + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//1.或者</span><br><span class="line">var obj = &#123;</span><br><span class="line">    get p() &#123;</span><br><span class="line">        return &#x27;getter&#x27;;</span><br><span class="line">    &#125;,</span><br><span class="line">    set p(value) &#123;</span><br><span class="line">        console.log(&#x27;setter:&#x27; + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">2.两种写法区别：第一种写法，属性p的configurable和enumerable都为false，从而导致属性p是不可遍历的；第二种写法，属性p的configurable和enumerable都为true，因此属性p是可遍历的</span><br><span class="line"></span><br><span class="line">3.实际开发中，第二种方法更加常用</span><br><span class="line"></span><br><span class="line">4.注意，取值函数get不能接受参数，存值函数set只能接受一个参数（即属性的值）</span><br><span class="line"></span><br><span class="line">obj.p // &quot;getter&quot;</span><br><span class="line">obj.p = 123 // &quot;setter: 123&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h2><p>如果我们不想这个对象添加更多的属性，那么可以使用Object.preventExtensions()方法禁止扩展 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj=&#123;a:2&#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">obj.b = 2;</span><br><span class="line">obj //&#123;a:2&#125;,已经无法添加新属了</span><br></pre></td></tr></table></figure><h2 id="密封"><a href="#密封" class="headerlink" title="密封"></a>密封</h2><p>密封就是禁止扩展的升级版,Object.seal()方法使得一个对象既无法添加新属性，也无法删除旧属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; p: &#x27;hello&#x27; &#125;;</span><br><span class="line">Object.seal(obj);</span><br><span class="line"></span><br><span class="line">delete obj.p;</span><br><span class="line">obj.p // &quot;hello&quot;  --&gt;1.无法被删除--&gt;其实质：将该属性描述对象的configurable属性设为false</span><br><span class="line"></span><br><span class="line">obj.x = &#x27;world&#x27;;</span><br><span class="line">obj.x // undefined  --&gt;2.无法添加新属性</span><br></pre></td></tr></table></figure><h2 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h2><p>冻结就是密封的升级版，Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  p: &#x27;hello&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.freeze(obj);</span><br><span class="line"></span><br><span class="line">obj.p = &#x27;world&#x27;;</span><br><span class="line">obj.p // &quot;hello&quot; --&gt;1.修改无效--&gt;其实质：把所有属性的writable给关掉(false)</span><br><span class="line"></span><br><span class="line">obj.t = &#x27;hello&#x27;;</span><br><span class="line">obj.t // undefined --&gt;2.无法添加新属性</span><br><span class="line"></span><br><span class="line">delete obj.p // false</span><br><span class="line">obj.p // &quot;hello --&gt;3.无法删除属性</span><br></pre></td></tr></table></figure><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="https://wangdoc.com/javascript/stdlib/attributes.html">https://wangdoc.com/javascript/stdlib/attributes.html</a><br><a href="https://juejin.cn/post/6898684702186717197">https://juejin.cn/post/6898684702186717197</a></p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端分部学习</title>
      <link href="/hexoblog.github.io/2022/09/15/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E9%83%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/hexoblog.github.io/2022/09/15/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E9%83%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="———————————————————————————"><a href="#———————————————————————————" class="headerlink" title="———————————————————————————"></a>———————————————————————————</h1><span id="more"></span><h1 id="前言：本来是想着补补大一大二的java后端知识，然后顺便做一做网上go相关的项目，但是现在dapp的课程貌似需要前端javaScript，ES6之类的前端知识，然后就顺便一起学了吧，重点dapp和java继续学习："><a href="#前言：本来是想着补补大一大二的java后端知识，然后顺便做一做网上go相关的项目，但是现在dapp的课程貌似需要前端javaScript，ES6之类的前端知识，然后就顺便一起学了吧，重点dapp和java继续学习：" class="headerlink" title="前言：本来是想着补补大一大二的java后端知识，然后顺便做一做网上go相关的项目，但是现在dapp的课程貌似需要前端javaScript，ES6之类的前端知识，然后就顺便一起学了吧，重点dapp和java继续学习："></a>前言：本来是想着补补大一大二的java后端知识，然后顺便做一做网上go相关的项目，但是现在dapp的课程貌似需要前端javaScript，ES6之类的前端知识，然后就顺便一起学了吧，重点dapp和java继续学习：</h1><p>修正：今天上课老师说了下技术栈是TypeScript，下来看了看这个TypeScript，说是JavaScript的超集…于是加入TypeScript，对了，忘了最重要的solidaty了</p><h2 id="javaScript快速入门："><a href="#javaScript快速入门：" class="headerlink" title="javaScript快速入门："></a>javaScript快速入门：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://wangdoc.com/javascript/index.html</span><br></pre></td></tr></table></figure><h2 id="阮一峰的ES6教程"><a href="#阮一峰的ES6教程" class="headerlink" title="阮一峰的ES6教程:"></a>阮一峰的ES6教程:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://es6.ruanyifeng.com/#README</span><br></pre></td></tr></table></figure><h2 id="TypeScript入门教程："><a href="#TypeScript入门教程：" class="headerlink" title="TypeScript入门教程："></a>TypeScript入门教程：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://ts.xcatliu.com/</span><br></pre></td></tr></table></figure><h2 id="Solidaty“僵尸教程”："><a href="#Solidaty“僵尸教程”：" class="headerlink" title="Solidaty“僵尸教程”："></a>Solidaty“僵尸教程”：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cryptozombies.io/</span><br></pre></td></tr></table></figure><h2 id="solodaty入门："><a href="#solodaty入门：" class="headerlink" title="solodaty入门："></a>solodaty入门：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html</span><br></pre></td></tr></table></figure><h2 id="Java学习路线，这里有两个，大致差不多，我以狂神提供的路线为主，另一个辅助来看："><a href="#Java学习路线，这里有两个，大致差不多，我以狂神提供的路线为主，另一个辅助来看：" class="headerlink" title="Java学习路线，这里有两个，大致差不多，我以狂神提供的路线为主，另一个辅助来看："></a>Java学习路线，这里有两个，大致差不多，我以狂神提供的路线为主，另一个辅助来看：</h2><p>狂神说Java全栈学习路线:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_33369905/article/details/106647296</span><br></pre></td></tr></table></figure><p>Java入门学习路线目录索引（持续更新中）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://onestar.blog.csdn.net/article/details/102394373</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>了解区块链世界</title>
      <link href="/hexoblog.github.io/2022/08/27/%E4%BA%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%96%E7%95%8C/"/>
      <url>/hexoblog.github.io/2022/08/27/%E4%BA%86%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="前言-学习新知识就是一个说服自己，打破自己旧的认知，然后重拾其碎片，加入其他的新的碎片最终-重组的过程"><a href="#前言-学习新知识就是一个说服自己，打破自己旧的认知，然后重拾其碎片，加入其他的新的碎片最终-重组的过程" class="headerlink" title="前言:学习新知识就是一个说服自己，打破自己旧的认知，然后重拾其碎片，加入其他的新的碎片最终 重组的过程"></a>前言:学习新知识就是一个说服自己，打破自己旧的认知，然后重拾其碎片，加入其他的新的碎片最终 重组的过程</h1><p>DAO<br>区块链预言机<br>web3.0<br>NFT<br>DAPP<br>Defi<br>Filecoin</p><hr><h1 id="DAO-Decentralized-Autonomous-Corporations-–去中心化自治组织-两篇文章入门看懂DAO"><a href="#DAO-Decentralized-Autonomous-Corporations-–去中心化自治组织-两篇文章入门看懂DAO" class="headerlink" title="DAO(Decentralized Autonomous Corporations)–去中心化自治组织,两篇文章入门看懂DAO:"></a>DAO(Decentralized Autonomous Corporations)–去中心化自治组织,两篇文章入门看懂DAO:</h1><h3 id="DAO是什么？著名的DAO项目介绍"><a href="#DAO是什么？著名的DAO项目介绍" class="headerlink" title="DAO是什么？著名的DAO项目介绍:"></a>DAO是什么？著名的DAO项目介绍:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.wwsww.cn/qkl/10698.html</span><br></pre></td></tr></table></figure><h3 id="去中心化组织-DAO-科普"><a href="#去中心化组织-DAO-科普" class="headerlink" title="去中心化组织(DAO)科普"></a>去中心化组织(DAO)科普</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/364778467</span><br></pre></td></tr></table></figure><h1 id="区块链预言机"><a href="#区块链预言机" class="headerlink" title="区块链预言机"></a>区块链预言机</h1><h3 id="什么是区块链预言机"><a href="#什么是区块链预言机" class="headerlink" title="什么是区块链预言机:"></a>什么是区块链预言机:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/263565159</span><br></pre></td></tr></table></figure><h1 id="web3-0"><a href="#web3-0" class="headerlink" title="web3.0"></a>web3.0</h1><h1 id="NFT"><a href="#NFT" class="headerlink" title="NFT"></a>NFT</h1><h1 id="DAPP-Decentralized-Application-–-去中心化应用程序-两篇文章分别了解和从小白开始学习开发Dapp？"><a href="#DAPP-Decentralized-Application-–-去中心化应用程序-两篇文章分别了解和从小白开始学习开发Dapp？" class="headerlink" title="DAPP(Decentralized Application)– 去中心化应用程序,两篇文章分别了解和从小白开始学习开发Dapp？"></a>DAPP(Decentralized Application)– 去中心化应用程序,两篇文章分别了解和从小白开始学习开发Dapp？</h1><h3 id="Dapp是什么？"><a href="#Dapp是什么？" class="headerlink" title="Dapp是什么？"></a>Dapp是什么？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/99806308</span><br></pre></td></tr></table></figure><h3 id="区块链Dapp开发教程"><a href="#区块链Dapp开发教程" class="headerlink" title="区块链Dapp开发教程"></a>区块链Dapp开发教程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/README-CN.md</span><br></pre></td></tr></table></figure><h1 id="DeFi"><a href="#DeFi" class="headerlink" title="DeFi"></a>DeFi</h1><h1 id="Filecoin"><a href="#Filecoin" class="headerlink" title="Filecoin"></a>Filecoin</h1><h1 id="闪电贷科普"><a href="#闪电贷科普" class="headerlink" title="闪电贷科普:"></a>闪电贷科普:</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_44383880/article/details/110412232</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>简易的比特币-区块链原型学习</title>
      <link href="/hexoblog.github.io/2022/08/21/%E7%AE%80%E6%98%93%E7%9A%84%E6%AF%94%E7%89%B9%E5%B8%81-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E5%9E%8B/"/>
      <url>/hexoblog.github.io/2022/08/21/%E7%AE%80%E6%98%93%E7%9A%84%E6%AF%94%E7%89%B9%E5%B8%81-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="前言：未来虚拟世界是绝对的独立智慧体（硅基生命），加密世界是绝对的一个大势，加密货币是绝对的一个刚需存在，虽然这个未来还有不少距离，但这个未来是一座灯塔。"><a href="#前言：未来虚拟世界是绝对的独立智慧体（硅基生命），加密世界是绝对的一个大势，加密货币是绝对的一个刚需存在，虽然这个未来还有不少距离，但这个未来是一座灯塔。" class="headerlink" title="前言：未来虚拟世界是绝对的独立智慧体（硅基生命），加密世界是绝对的一个大势，加密货币是绝对的一个刚需存在，虽然这个未来还有不少距离，但这个未来是一座灯塔。"></a>前言：未来虚拟世界是绝对的独立智慧体（硅基生命），加密世界是绝对的一个大势，加密货币是绝对的一个刚需存在，虽然这个未来还有不少距离，但这个未来是一座灯塔。</h1><pre><code>                                                                 --一位优秀的网络答主</code></pre><h3 id="Go语言实现-github地址学习地址-代码"><a href="#Go语言实现-github地址学习地址-代码" class="headerlink" title="Go语言实现,github地址学习地址(代码):"></a>Go语言实现,github地址学习地址(代码):</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Jeiwan/blockchain_go.git</span><br></pre></td></tr></table></figure><h3 id="中文文档地址"><a href="#中文文档地址" class="headerlink" title="中文文档地址"></a>中文文档地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_40392981/category_11632873.html</span><br></pre></td></tr></table></figure><h3 id="生成区块链小工具："><a href="#生成区块链小工具：" class="headerlink" title="生成区块链小工具："></a>生成区块链小工具：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blockchaindemo.io/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Goland文件数据库-Bolt库简单操作</title>
      <link href="/hexoblog.github.io/2022/08/20/Goland%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-Bolt%E5%BA%93%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/hexoblog.github.io/2022/08/20/Goland%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-Bolt%E5%BA%93%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="bolt简介"><a href="#bolt简介" class="headerlink" title="bolt简介"></a>bolt简介</h2><ul><li>bolt数据库是一个<strong>纯GO语言</strong>实现的<strong>键值对数据库</strong>，支持完全的ACID事务操作.</li><li>bolt库通过使用一个内存映射的磁盘文件来管理数据，逻辑清晰，接口简单易用；</li><li>相比于使用数据库连接工具类的东西比如mysql、SQlite来操作数据持久化，而是通过一个文件(bucket)来存储数据，虽然访问不够灵活，但是效率比较高，所以可以考虑用bolt库来进行测试</li></ul><h2 id="bolt安装"><a href="#bolt安装" class="headerlink" title="bolt安装"></a>bolt安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/boltdb/bolt</span><br></pre></td></tr></table></figure><h2 id="bolt使用"><a href="#bolt使用" class="headerlink" title="bolt使用"></a>bolt使用</h2><p>###操作打开以及关闭Bolt库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义db文件名常量</span><br><span class="line">const dbFile=&quot;my.db&quot;</span><br><span class="line"></span><br><span class="line">//需要使用到的函数:func Open(path string, mode os.FileMode, options *Options) (*DB, error)</span><br><span class="line">//Open函数接受三个参数：</span><br><span class="line">  //第一个参数表示bucket路径，第二个参数表示操作方式，第三个参数表示配置信息，没有明确可以不配置，直接写nil</span><br><span class="line"></span><br><span class="line">//打开.db文件，如果不存在则创建，如果存在则打开</span><br><span class="line">db,err := bolt.Open(dbFile,0666,nil)</span><br><span class="line">    //错误处理</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;db文件查找或创建失败，请稍后重试&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    //关闭</span><br><span class="line">defer db.Close()</span><br></pre></td></tr></table></figure><h3 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction(事务)"></a>Transaction(事务)</h3><h5 id="Bolt数据库同时只支持一个read-write-transaction或者多个read-only-transaction，一般来说read-only的transaction和read-write-transaction不应该相互之间有依赖，即同一个goroutinr中不要同时打开这两种transaction–-gt-可能会出现死锁的情况"><a href="#Bolt数据库同时只支持一个read-write-transaction或者多个read-only-transaction，一般来说read-only的transaction和read-write-transaction不应该相互之间有依赖，即同一个goroutinr中不要同时打开这两种transaction–-gt-可能会出现死锁的情况" class="headerlink" title="Bolt数据库同时只支持一个read-write transaction或者多个read-only transaction，一般来说read-only的transaction和read-write transaction不应该相互之间有依赖，即同一个goroutinr中不要同时打开这两种transaction–&gt;(可能会出现死锁的情况)"></a>Bolt数据库同时只支持一个read-write transaction或者多个read-only transaction，一般来说read-only的transaction和read-write transaction不应该相互之间有依赖，即同一个goroutinr中不要同时打开这两种transaction–&gt;(可能会出现死锁的情况)</h5><h3 id="Read-write-transactions-读写事务"><a href="#Read-write-transactions-读写事务" class="headerlink" title="Read-write transactions(读写事务)"></a>Read-write transactions(读写事务)</h3><p> 通过DB.Update打开一个read-write transaction:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//定义bucketName常量</span><br><span class="line">const bucketName=&quot;bucket01&quot;</span><br><span class="line"></span><br><span class="line">//db为上面通过Open()函数(打开文件)获取的操作对象</span><br><span class="line">if err:=db.Update(func(tx *bolt.Tx) error)&#123;</span><br><span class="line"></span><br><span class="line">    // CreateBucket() creates a new bucket.(bucket中的所有key必须是唯一的)</span><br><span class="line">    //在Update事务中可以更改操作(创建bucket,修改bucket中某个键的值等等)</span><br><span class="line">    if _, err = tx.CreateBucket([]byte(&quot;bucketName&quot;)); err != nil &#123;</span><br><span class="line">          logger.Log(&quot;create failed&quot;, err)</span><br><span class="line">          return err</span><br><span class="line">         &#125;</span><br><span class="line">         return nil</span><br><span class="line">&#125;);;err!=nil&#123;</span><br><span class="line">    log.panic(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Read-Only-transactions（只读事务）"><a href="#Read-Only-transactions（只读事务）" class="headerlink" title="Read-Only transactions（只读事务）"></a>Read-Only transactions（只读事务）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if err := db.View(func(tx *bolt.Tx) error &#123;</span><br><span class="line">        // if _, err := tx.CreateBucket([]byte(&quot;bucketName&quot;)); err != nil &#123;</span><br><span class="line">        //  logger.Log(&quot;create failed&quot;, err)</span><br><span class="line">        //  return err</span><br><span class="line">        // &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;); err != nil &#123;</span><br><span class="line">        log.panic(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>View()中不允许更改操作,只能获取bucket,查询value,复制数据库,所以上面注释代码加上会报错</p><h3 id="使用key-x2F-value"><a href="#使用key-x2F-value" class="headerlink" title="使用key&#x2F;value"></a>使用key&#x2F;value</h3><p>将一个key&#x2F;value保存到bucket中**(保存在bucket中的键值对是无序的)**,使用Bucket.Put()函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if err:=db.Update(func(tx *bolt.Tx) error)&#123;</span><br><span class="line">    b:=tx.Bucket([]byte(bucketName))</span><br><span class="line"></span><br><span class="line">    //Put sets the value for a key in the bucket.</span><br><span class="line">    //需要传入两个字节数组,第一个字节数组作为key值,第二个字节数组作为对应key值的value值</span><br><span class="line">    err=b.Put([]byte(&quot;1&quot;),[]byte(&quot;&quot;block01))</span><br><span class="line">    return err</span><br><span class="line"></span><br><span class="line">    //return nil</span><br><span class="line">&#125;);err!=nil&#123;</span><br><span class="line">    logger.Log(&quot;update&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>上面代码的”1”-&gt;”block01” key-value对保存到bucket “bucket01”中，可以使用Bucket.Get()函数获取”block01”这个值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if err:=db.View(func(tx *bolt.Tx) error &#123;</span><br><span class="line"> b := tx.Bucket([]byte(&quot;bucketName&quot;))</span><br><span class="line">        //Get retrieves the value for a key in the bucket.</span><br><span class="line">        //需要一个传入类型为字节数组的&quot;key&quot;值</span><br><span class="line">        v := b.Get([]byte(&quot;1&quot;))</span><br><span class="line">        fmt.Printf(&quot;the anser is :%s\n&quot;, v)</span><br><span class="line"></span><br><span class="line">        return nil</span><br><span class="line">    &#125;); err != nil &#123;</span><br><span class="line">        logger.Log(&quot;view&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最后附上一张图说明-db文件和bucket的关系"><a href="#最后附上一张图说明-db文件和bucket的关系" class="headerlink" title="最后附上一张图说明.db文件和bucket的关系:"></a>最后附上一张图说明.db文件和bucket的关系:</h2><img src="/hexoblog.github.io/2022/08/20/Goland%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93-Bolt%E5%BA%93%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/bucket.png" class title="This is an relative image">]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单算法</title>
      <link href="/hexoblog.github.io/2022/08/06/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/"/>
      <url>/hexoblog.github.io/2022/08/06/%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li>二分算法</li><li>冒泡排序算法</li><li>插入排序算法</li><li>归并排序算法</li><li>快速排序算法</li><li>希尔排序算法</li></ul><h2 id="二分算法–时间复杂度O-logn"><a href="#二分算法–时间复杂度O-logn" class="headerlink" title="二分算法–时间复杂度O(logn)"></a>二分算法–时间复杂度O(logn)</h2><h3 id="二分算法不用纠结数组长度是奇数还是偶数-因为中间的数字两边的数字不一样-，只需要记住："><a href="#二分算法不用纠结数组长度是奇数还是偶数-因为中间的数字两边的数字不一样-，只需要记住：" class="headerlink" title="二分算法不用纠结数组长度是奇数还是偶数(因为中间的数字两边的数字不一样)，只需要记住："></a>二分算法不用纠结数组长度是奇数还是偶数(因为中间的数字两边的数字不一样)，只需要记住：</h3><ol><li>只要中间数字大于目标数字，就排除右边的</li><li>只要中间数字小于目标数字，就排除左边的</li></ol><p><strong>所以关键问题是中间那个数字到底该不该加入下一次的查找中，也就是边界问题中最重要的两个点</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.while循环中left和right的关系，到底是left&lt;=right还是left&gt;right</span><br><span class="line">2.迭代过程中middle和right的关系，到底是right=middle-1还是right=middle</span><br></pre></td></tr></table></figure><h3 id="第一种写法-左闭右闭-；"><a href="#第一种写法-左闭右闭-；" class="headerlink" title="第一种写法(左闭右闭)；"></a>第一种写法(左闭右闭)；</h3><p>因为target在[left,right]区间，所以有以下两点需要注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.循环要使用while(left&lt;=right)，因为当(left==right)的时候，得到的结果才是有意义的</span><br><span class="line">2.rigth每次更新需要middle减一，left每次更新需要middle加一，更新操作时，此时的未更新的middle一定不等于target值</span><br></pre></td></tr></table></figure><h3 id="具体代码-go-："><a href="#具体代码-go-：" class="headerlink" title="具体代码(go)："></a>具体代码(go)：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func Search(nums []int, target int) int &#123;</span><br><span class="line">    left:=0</span><br><span class="line">    right:=len(nums)-1</span><br><span class="line">    for ;left&lt;=right;&#123;</span><br><span class="line">         middle:=(left+right)/2//更新middle，取整操作</span><br><span class="line">         if target&gt;nums[middle]&#123;</span><br><span class="line">             left=middle+1//更新left</span><br><span class="line">         &#125;else if target&lt;nums[middle]&#123;</span><br><span class="line">             right=middle-1//更新right</span><br><span class="line">         &#125;else&#123;    </span><br><span class="line">         return middle</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二种写法-左闭右闭-："><a href="#第二种写法-左闭右闭-：" class="headerlink" title="第二种写法(左闭右闭)："></a>第二种写法(左闭右闭)：</h2><p>区间为[left,right)，所以需要注意以下两个点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">循环条件使用while(left&lt;right)</span><br><span class="line">因为更新前的nums[middle]是大于target的，,并且由于当前区间是[left,right)所以需要right=middle</span><br></pre></td></tr></table></figure><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func Search(nums []int, target int) int &#123;</span><br><span class="line">    left:=0</span><br><span class="line">    right:=len(nums)//区间[left,right)</span><br><span class="line">    for ;left&lt;right;&#123;</span><br><span class="line">         middle:=(left+right)/2//更新middle,取整操作</span><br><span class="line">         if target&gt;nums[middle]&#123;</span><br><span class="line">             left=middle+1//更新left</span><br><span class="line">         &#125;else if target&lt;nums[middle]&#123;</span><br><span class="line">             right=middle//更新right</span><br><span class="line">         &#125;else&#123;    </span><br><span class="line">         return middle</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结：二分法最重要的两个点，就是循环条件和后续区间赋值问题"><a href="#总结：二分法最重要的两个点，就是循环条件和后续区间赋值问题" class="headerlink" title="总结：二分法最重要的两个点，就是循环条件和后续区间赋值问题"></a>总结：二分法最重要的两个点，就是循环条件和后续区间赋值问题</h3><h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://blog.csdn.net/qq_45978890/article/details/116094046">https://blog.csdn.net/qq_45978890/article/details/116094046</a></p><hr><h2 id="冒泡排序算法–时间复杂度O-n2-–稳定算法"><a href="#冒泡排序算法–时间复杂度O-n2-–稳定算法" class="headerlink" title="冒泡排序算法–时间复杂度O(n2)–稳定算法"></a>冒泡排序算法–时间复杂度O(n2)–稳定算法</h2><h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><ol><li>比较相邻的元素，如果第一个比第二个大，就交换他们两个;</li><li>对每一对相邻元素左同样的工作，从开始第一对到结尾最后一对;</li><li>针对所有的元素重复以上的步骤，除了最后一个;</li><li>重复步骤1~3，直到排序完成.</li></ol><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.针对所有元素重复交换步骤，除了最后一个，所以外层循环次数应该是len(nums)-1 </span><br><span class="line">2.每一次最外层循环完向右移动一位时内层循环也相应需要向右移动一位，并且每一次内层循环需要从外层循环的右边一个位置开始,所以每次初始化内存循环为内存右边以外一位开始，循环次数为数组长度len(arrs)-1-i(外层开始点位)</span><br></pre></td></tr></table></figure><h3 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下:"></a>代码如下:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func BubbleSort(arrs *[]int) arrs []int&#123;</span><br><span class="line">    for i:=0;i&lt;len(*arrs)-1;i++&#123;</span><br><span class="line">        for j:=i+1;j&lt;len(*arrs)-1-i;j++&#123;</span><br><span class="line">            if arr[j]&gt;arr[j+1]&#123;</span><br><span class="line">                arr[j],arr[j+1]=arr[j+1],arr[j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序–时间复杂度O-n2-–稳定算法"><a href="#选择排序–时间复杂度O-n2-–稳定算法" class="headerlink" title="选择排序–时间复杂度O(n2)–稳定算法"></a>选择排序–时间复杂度O(n2)–稳定算法</h2><h3 id="算法原理-1"><a href="#算法原理-1" class="headerlink" title="算法原理"></a>算法原理</h3><ol><li>在未排序序列中找到最小(大)元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小(大)元素，然后放到已排序序列的末尾，以此类推</li><li>初始状态：无序区未arr[1,n],有序区为空</li><li>第i趟排序，当前有序区和无序区分别为R[1,…,i-1]和R(i,…,n),在无序区中依次比较交换，选出i位置应该最小或者最大的值，这样有序区记录个数增加一个，无序区记录格式减少一个</li><li>n-1趟结束，数组变为有序化数组</li></ol><h3 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.外层有序点位只需要到n-2的位置，最后一个点位在n-2排序后就是最佳</span><br><span class="line">2.内层循环需要从外层循环点位的下一位开始</span><br></pre></td></tr></table></figure><h3 id="代码如下-以递增排序为例-："><a href="#代码如下-以递增排序为例-：" class="headerlink" title="代码如下(以递增排序为例)："></a>代码如下(以递增排序为例)：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func SelectionSort(arr []int)&#123;</span><br><span class="line">    for i:=0;i&lt;len(arr)-1;i++&#123;</span><br><span class="line">        minIndex:=i</span><br><span class="line">        for j:=i+1;j&lt;len(arr);j++&#123;</span><br><span class="line">            if arr[j]&lt;arr[minIndex]&#123; //小于--&gt;算法稳定;小于等于算法不稳定</span><br><span class="line">                minIndex=j//点位交换，在内层循环内</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i],arr[minIndex]=arr[minIndex],arr[i]//值交换在外层循环内，内层循环外</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="直接-插入排序–时间复杂度O-n2-–稳定算法"><a href="#直接-插入排序–时间复杂度O-n2-–稳定算法" class="headerlink" title="(直接)插入排序–时间复杂度O(n2)–稳定算法"></a>(直接)插入排序–时间复杂度O(n2)–稳定算法</h2><h3 id="算法原理-2"><a href="#算法原理-2" class="headerlink" title="算法原理"></a>算法原理</h3><ol><li>将待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已经排好序的</li><li>从第二个元素开始，在已排好的的部分数组中找到适合该元素的位置并且插入</li><li>重复以上步骤，知道最后一个元素插入有序数组部分</li></ol><h3 id="注意：-2"><a href="#注意：-2" class="headerlink" title="注意："></a>注意：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为默认数组第一个元素为有序数组部分，所以插入元素应该从数组第二位开始，即外层循环从数组第二位开始</span><br></pre></td></tr></table></figure><h3 id="代码如下-go-："><a href="#代码如下-go-：" class="headerlink" title="代码如下(go)："></a>代码如下(go)：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func InsertSort(arr []int)&#123;</span><br><span class="line">    for i:=1;i&lt;len(arr);i++&#123;</span><br><span class="line">        j:=i</span><br><span class="line">        for ;j&gt;0;&#123;</span><br><span class="line">            if arr[j]&lt;arr[j-1]&#123;</span><br><span class="line">                arr[j],arr[j-1]=arr[j-1],arr[j]</span><br><span class="line">                j-=1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序-分治法-–时间复杂度O-n"><a href="#归并排序-分治法-–时间复杂度O-n" class="headerlink" title="归并排序(分治法)–时间复杂度O(n)"></a>归并排序(分治法)–时间复杂度O(n)</h2><h3 id="算法原理-3"><a href="#算法原理-3" class="headerlink" title="算法原理"></a>算法原理</h3><ol><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列</li><li>对这两个子序列分别采用重复步骤一至不可再分；</li><li>将已排好序的子序列重新向上合并成一个完整的有序序列</li></ol><h3 id="代码如下-go"><a href="#代码如下-go" class="headerlink" title="代码如下(go)"></a>代码如下(go)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//归并算法：将两个已经有序的子序列归并为一个有序的序列</span><br><span class="line">func merge(left,right []int) []int&#123;</span><br><span class="line">    result:=make([]int,0)//</span><br><span class="line">    i,j:=0,0 //左序列和右序列的初始位置</span><br><span class="line">    for i&lt;len(left)&amp;&amp;j&lt;len(right)&#123;</span><br><span class="line">        if left[i]&lt;right[j]&#123;</span><br><span class="line">            result=append(result,left[i])</span><br><span class="line">            i+=1</span><br><span class="line">            continue</span><br><span class="line">        &#125;</span><br><span class="line">        result=append(result,right[j])</span><br><span class="line">        j+=1</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    result=append(result,left[i:]...)</span><br><span class="line">    result=append(result,right[j:]...)</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func MergeSort(arr []int) []int&#123;</span><br><span class="line">     if len(arr)&lt;2&#123;</span><br><span class="line">        return arr</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">        i:=len(arr)/2</span><br><span class="line">        left:=MergeSort(arr[0:i])</span><br><span class="line">        right:=MergeSort(arr[i:])</span><br><span class="line">        result:=merge(left,right)</span><br><span class="line">        return right</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####################################################</p><h2 id="快速排序-分治法-–算法复杂度O-nlogn"><a href="#快速排序-分治法-–算法复杂度O-nlogn" class="headerlink" title="快速排序(分治法)–算法复杂度O(nlogn)"></a>快速排序(分治法)–算法复杂度O(nlogn)</h2><h3 id="算法原理-4"><a href="#算法原理-4" class="headerlink" title="算法原理"></a>算法原理</h3><ol><li>分解：先给定一个基准p(pivot)，然后根据基准p将数组arr[l,r]分区(partition),即划分为两个（可能为空）子数组A[l…p-1]和A[p+1…r]，使得A[l…p-1]中的每个元素小于等于A[p]，A[p+1…r]中的每个元素大于等于A[p]，q下标是在划分过程中计算得出的</li><li>解决：通过递归的(recursive)调用快速排序，对小于基准元素的子数组A[l…p-1]和大于基准元素的子数组A[p+1…r]进行排序</li><li>合并：因为两个子数组是就地排序，不需要合并操作，整个数组A[l…r]排序完成</li></ol><h3 id="注意：-3"><a href="#注意：-3" class="headerlink" title="注意："></a>注意：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准点和基准值：基准点以该点左边是小于此点的值的元素值，基准值是数值与位置信息无关</span><br></pre></td></tr></table></figure><h3 id="代码如下：-1"><a href="#代码如下：-1" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func QuickSort(arr []int,l int,r int)&#123;</span><br><span class="line">    if l&lt;r&#123;</span><br><span class="line">        p:=partition(arr,l,r)//基准点</span><br><span class="line">        partition(arr,l,p-1)//分区</span><br><span class="line">        partition(arr,p+1,r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func partition(arr []int, l int, r int)int&#123;</span><br><span class="line">    key:=arr[r]//以right位置上的值为基准值</span><br><span class="line">    i:=l</span><br><span class="line">    j:=l</span><br><span class="line">    for j&lt;r&#123;//j需要经过基准点前的所有数组元素。</span><br><span class="line">        if arr[j]&lt;key&#123;</span><br><span class="line">            arr[i],arr[j]=arr[j],arr[i]</span><br><span class="line">            i+=1</span><br><span class="line">        &#125;</span><br><span class="line">        j+=1</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i],arr[r]=arr[r],arr[i]</span><br><span class="line">    return i//基准点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="希尔排序–平均算法复杂度O-nlogn-–不稳定"><a href="#希尔排序–平均算法复杂度O-nlogn-–不稳定" class="headerlink" title="希尔排序–平均算法复杂度O(nlogn)–不稳定"></a>希尔排序–平均算法复杂度O(nlogn)–不稳定</h2><h3 id="算法原理-5"><a href="#算法原理-5" class="headerlink" title="算法原理"></a>算法原理</h3><ol><li>每一趟排序都需要首先定义一个增量(步长),如果起始增量(步长)定义为gap&#x3D;length&#x2F;2(这个增量称为希尔增量，当然增量长度可以自己定义)，那么这里每一趟的增量可以用一个序列来表示：{gap&#x2F;2,(gap&#x2F;2)&#x2F;2,…,1}</li><li>每一趟的增量那么将整个数组分为这个增量大小的数组，然后对每一组分别进行直接插入排序，小的元素被调换到前面，然后缩小增量进行下一趟的排序</li><li>直到增量缩小到1时，最后对序列进行调整，整个数组排序完成</li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组元素个数是偶数或者奇数不影响</span><br></pre></td></tr></table></figure><h3 id="代码如下：-2"><a href="#代码如下：-2" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func ShellSort(arr []int) []int&#123;</span><br><span class="line">    gap:=len(arr)/2 //定义增量(步长)，向下取整</span><br><span class="line">    for gap&gt;0&#123; //gap等于1的时候是最后一次调整</span><br><span class="line">        for i:=0;i&lt;len(arr);i++&#123;</span><br><span class="line">            j:=i</span><br><span class="line">            for ((j-gap&gt;0) &amp;&amp; (arr[j]&lt;arr[j-gap]))&#123;</span><br><span class="line">                arr[j],arr[j-gap]=arr[j-gap],arr[j] //交换</span><br><span class="line">                j-=gap //跳出这一层while循环--&gt;关键点</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       gap/=2 //每一趟过后gap更新</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Goland循环导包报错</title>
      <link href="/hexoblog.github.io/2022/07/13/Goland%E5%BE%AA%E7%8E%AF%E5%AF%BC%E5%8C%85%E6%8A%A5%E9%94%99/"/>
      <url>/hexoblog.github.io/2022/07/13/Goland%E5%BE%AA%E7%8E%AF%E5%AF%BC%E5%8C%85%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p><strong>“imiport cycle not allow”</strong>–&gt;这是今天我在goland中添加redis时遇到的一个问题，整体代码书写没有报错，但是debug就出现了这样的问题：</p><img src="/hexoblog.github.io/2022/07/13/Goland%E5%BE%AA%E7%8E%AF%E5%AF%BC%E5%8C%85%E6%8A%A5%E9%94%99/redis.png" class title="This is an 报错 image"><p>发现是由于导包时因为包和代码规划有些问题，出现了cache的包需要导入config包里面的配置信息，而config包里的init()初始化函数初始化redis需要redis逻辑包里面的启动，这就导致了两个包循环导用的情况：</p><img src="/hexoblog.github.io/2022/07/13/Goland%E5%BE%AA%E7%8E%AF%E5%AF%BC%E5%8C%85%E6%8A%A5%E9%94%99/config.png" class title="This is an rustBug image"><h2 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h2><p>golang检测出现循环导包的时候就会在编译阶段报错，通常是因为设计错误或包的规划问题：（<code>package C</code>导入了<code>package A</code>和<code>package B</code>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import(</span><br><span class="line">    &quot;package A&quot;</span><br><span class="line">    &quot;package B&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>而在<code>package A</code> 中导入了<code>package C</code>，在<code>package B</code>中导入了<code>package C</code></p><p>或者说在<code>package C</code>依赖于<code>package A</code>和<code>package B</code>的情况下，<code>package A</code>依赖于<code>package C</code>，同时package B依赖<code>package C</code>，这个时候就会在编译时出现<code>imiport cycle not allow</code></p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>由于我的想的是config包里定义的是总体的初始化读取配置，那么就在config文件中读取redis的配置信息，然后调用cache包的初始化逻辑，这样可以减少redis的内部包的定义和减少配置函数的定义<br>出现这种错误后，我就将redis的读取文件操作和初始化处理逻辑和需要用到的逻辑函数单独放在了cache包，debug–&gt;成功！！！</p><h2 id="如何避免以及出现了如何解决？"><a href="#如何避免以及出现了如何解决？" class="headerlink" title="如何避免以及出现了如何解决？"></a>如何避免以及出现了如何解决？</h2><h3 id="那么这个如果在设计之初规划好包是可以避免的，那难免也有出现了急待解决的时候，这里大概有两种比较好的思路："><a href="#那么这个如果在设计之初规划好包是可以避免的，那难免也有出现了急待解决的时候，这里大概有两种比较好的思路：" class="headerlink" title="那么这个如果在设计之初规划好包是可以避免的，那难免也有出现了急待解决的时候，这里大概有两种比较好的思路："></a>那么这个如果在设计之初规划好包是可以避免的，那难免也有出现了急待解决的时候，这里大概有两种比较好的思路：</h3><ol><li><p>定义接口</p></li><li><p>拆分包</p></li></ol><p>参考文章:<br>(<a href="https://blog.csdn.net/ggq89/article/details/81148558">https://blog.csdn.net/ggq89/article/details/81148558</a>)</p>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摄影中的曝光</title>
      <link href="/hexoblog.github.io/2022/07/12/%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E6%9B%9D%E5%85%89/"/>
      <url>/hexoblog.github.io/2022/07/12/%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E6%9B%9D%E5%85%89/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>曝光是摄影中比较重要的知识，在我们日常生活中可以理解为光的强弱带给人眼的感受，主要呈现在画面中的明暗对比，包括熟悉的曝光三要素；理解了曝光三要素后，这样每次我们在进行拍摄以及后期处理完都可以尝试在照片合适的位置加上拍摄此照片曝光三要素的基本信息；除此外，因为我本人使用的第一台相机是一台全画幅的尼康相机，所以我会就其模式介绍每种模式对应下的功能和场景，这样会有更深的理解（本人非专业摄影）</p><h2 id="曝光三要素：一般指的是光圈、快门、感光度ISO"><a href="#曝光三要素：一般指的是光圈、快门、感光度ISO" class="headerlink" title="曝光三要素：一般指的是光圈、快门、感光度ISO"></a>曝光三要素：一般指的是光圈、快门、感光度ISO</h2><h3 id="光圈：光圈一般以大小来区分，它是控制照射到传感器的进光量"><a href="#光圈：光圈一般以大小来区分，它是控制照射到传感器的进光量" class="headerlink" title="光圈：光圈一般以大小来区分，它是控制照射到传感器的进光量"></a>光圈：光圈一般以大小来区分，它是控制照射到传感器的进光量</h3><p>光圈的显示：</p><ul><li>“F+数字”:数字越小，光圈越大，数字越大，光圈越小；范围在F1.8(大光圈)-F22(小光圈)之间</li></ul><p>光圈的作用：</p><ul><li><p>调节亮度：光圈越大，进光量就越多，画面趋势于亮；反之光圈越小，进光量越少，画面趋势于暗</p></li><li><p>调节景深：光圈越大，景深越浅，突出主体，背景越模糊；光圈越小，景深越深，背景越清晰</p></li><li><p>光圈调节：主要是在A挡（Av档）光圈优先模式下和M挡模式下调节</p></li></ul><p>光圈应用:</p><ul><li><p>大光圈:适合拍摄想突出主体的物体或人(虚化效果),也适合弱光环境</p></li><li><p>小光圈:适合拍整个场景时(减小虚化和景深),也适合拍整个星空和灯光或车的轨迹</p></li></ul><h3 id="快门-快门速度-：光线照射传感器的持续时间，一般以快门衡量"><a href="#快门-快门速度-：光线照射传感器的持续时间，一般以快门衡量" class="headerlink" title="快门(快门速度)：光线照射传感器的持续时间，一般以快门衡量"></a>快门(快门速度)：光线照射传感器的持续时间，一般以快门衡量</h3><p>快门的显示:</p><img src="/hexoblog.github.io/2022/07/12/%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E6%9B%9D%E5%85%89/%E5%BF%AB%E9%97%A801.png" class title="This is an 快门 image"><ul><li>（如上图，以我的D610为例,标注红圈为快门速度）</li></ul><h3 id="快门的作用："><a href="#快门的作用：" class="headerlink" title="快门的作用："></a>快门的作用：</h3><ul><li><p>调节亮度：快门速度越快，画面越暗；快门速度越慢，画面越亮</p></li><li><p>控制动态影像的成像效果:快门速度越快，则拍摄运动的物体就越清晰（适合拍高速运动的物体，如运动员之类的）；快门速度越慢，则拍摄运动的物体就越模糊（雾化的流水或者星空的轨迹）</p></li></ul><p>快门的调节：</p><ul><li>主要在S档（Tv档）快门优先模式或者M档手动模式调节快门速度</li></ul><p>快门应用：</p><ul><li><p>快门速度快（清晰）：定格瞬间，拍摄高速运动的物体</p></li><li><p>快门速度慢（模糊）：记录轨迹，拍摄瀑布或者星空</p></li></ul><h3 id="感光度ISO：传感器对光线的敏感程度"><a href="#感光度ISO：传感器对光线的敏感程度" class="headerlink" title="感光度ISO：传感器对光线的敏感程度"></a>感光度ISO：传感器对光线的敏感程度</h3><p>感光度的显示：</p><img src="/hexoblog.github.io/2022/07/12/%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E6%9B%9D%E5%85%89/%E6%84%9F%E5%85%89%E5%BA%A6.png" class title="This is an 感光度 image"><ul><li>(如上图所标)，用”ISO+数字”表示，数字越大，感光度越高；数字越小感光度越小</li></ul><p>感光度作用：</p><ul><li><p>调节亮度：感光度越高，画面越亮；感光度越低，画面越暗</p></li><li><p>影响噪点（画质）：感光度越高，噪点越多，画质越粗糙；感光度越低，噪点越少，画质越细腻</p></li></ul><p>感光度的应用：</p><ul><li><p>低感光度（相对细腻）：适合风光或者和高质量的印刷作品，并且在室外光线充足的情况下使用</p></li><li><p>高感光度（相对粗糙）：在一些画面较暗需要高速抓拍时可以使用，夜景或者雾景可以使用</p></li></ul><h3 id="三要素的搭配"><a href="#三要素的搭配" class="headerlink" title="三要素的搭配"></a>三要素的搭配</h3><h3 id="曝光补偿：曝光补偿是一种控制方式，在非手动曝光模式下，可以通过曝光补偿自动调节曝光参数，增加曝光则相片明亮，反之则暗"><a href="#曝光补偿：曝光补偿是一种控制方式，在非手动曝光模式下，可以通过曝光补偿自动调节曝光参数，增加曝光则相片明亮，反之则暗" class="headerlink" title="曝光补偿：曝光补偿是一种控制方式，在非手动曝光模式下，可以通过曝光补偿自动调节曝光参数，增加曝光则相片明亮，反之则暗"></a>曝光补偿：曝光补偿是一种控制方式，在非手动曝光模式下，可以通过曝光补偿自动调节曝光参数，增加曝光则相片明亮，反之则暗</h3><hr><h3 id="尼康D610的所有模式"><a href="#尼康D610的所有模式" class="headerlink" title="尼康D610的所有模式"></a>尼康D610的所有模式</h3><h4 id="P档："><a href="#P档：" class="headerlink" title="P档："></a>P档：</h4><h4 id="S档："><a href="#S档：" class="headerlink" title="S档："></a>S档：</h4><h4 id="A档："><a href="#A档：" class="headerlink" title="A档："></a>A档：</h4><h4 id="M档："><a href="#M档：" class="headerlink" title="M档："></a>M档：</h4><h4 id="u2："><a href="#u2：" class="headerlink" title="u2："></a>u2：</h4><h4 id="u1："><a href="#u1：" class="headerlink" title="u1："></a>u1：</h4><h4 id="SCENE："><a href="#SCENE：" class="headerlink" title="SCENE："></a>SCENE：</h4><h4 id="⚡："><a href="#⚡：" class="headerlink" title="⚡："></a>⚡：</h4><h4 id="AUTO："><a href="#AUTO：" class="headerlink" title="AUTO："></a>AUTO：</h4><h4 id="S"><a href="#S" class="headerlink" title="S:"></a>S:</h4><h4 id="CL"><a href="#CL" class="headerlink" title="CL:"></a>CL:</h4><h4 id="CH"><a href="#CH" class="headerlink" title="CH:"></a>CH:</h4><h4 id="Q"><a href="#Q" class="headerlink" title="Q:"></a>Q:</h4><h4 id="Qc"><a href="#Qc" class="headerlink" title="Qc:"></a>Qc:</h4><h4 id="⏰："><a href="#⏰：" class="headerlink" title="⏰："></a>⏰：</h4><h4 id><a href="#" class="headerlink" title></a></h4><h4 id="Mup："><a href="#Mup：" class="headerlink" title="Mup："></a>Mup：</h4>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影三要素 曝光 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>谈谈摄影中的光线</title>
      <link href="/hexoblog.github.io/2022/07/10/%E8%B0%88%E8%B0%88%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E5%85%89%E7%BA%BF/"/>
      <url>/hexoblog.github.io/2022/07/10/%E8%B0%88%E8%B0%88%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E5%85%89%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="前言：此篇大概从五个方面总结深入摄影需要了解的光线知识，涵盖面比较广，可能比较书面化，需要动手实践去用相机捕捉然后适当提升自己的审美才会有更深的体会"><a href="#前言：此篇大概从五个方面总结深入摄影需要了解的光线知识，涵盖面比较广，可能比较书面化，需要动手实践去用相机捕捉然后适当提升自己的审美才会有更深的体会" class="headerlink" title="前言：此篇大概从五个方面总结深入摄影需要了解的光线知识，涵盖面比较广，可能比较书面化，需要动手实践去用相机捕捉然后适当提升自己的审美才会有更深的体会"></a>前言：此篇大概从五个方面总结深入摄影需要了解的光线知识，涵盖面比较广，可能比较书面化，需要动手实践去用相机捕捉然后适当提升自己的审美才会有更深的体会</h1><h2 id="强度"><a href="#强度" class="headerlink" title="强度"></a>强度</h2><ul><li><p>强光：泛指光线很强的光，亮度比较大，照射物体会形成强烈的阴影，拍摄效果比较清晰，结合较暗的背景可以凸显主体</p></li><li><p>弱光：泛指光线较弱的光，比较柔和，适合拍氛围感的照片</p></li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li><p>暖光：颜色偏红黄的光，大概在3000k以下，给人以温暖的感觉</p></li><li><p>冷光：颜色偏青蓝的光，大概在色温超过5000k，有清冷的感觉</p></li></ul><h2 id="光源"><a href="#光源" class="headerlink" title="光源"></a>光源</h2><ul><li><p>自然光：泛指大自然当中的光线，常见的比如日光和月光，通常自然光拍摄能够还原场景的真实氛围</p></li><li><p>环境光：指拍摄环境中自然存在的光，包括自然光（区别–&gt;包含关系）以及室内的照明光等</p></li><li><p>人造光：拍摄者有意制造并加入拍摄的光，泛指设备产生的光，比如闪光灯，日光灯等</p></li></ul><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><ul><li><p>顺光:也叫正面光，从正面照射到被摄物体的光，受光主体部分会受到比较均匀的照明，影调比较柔和，，对于被摄物体的细节和色彩部分捕捉比较好，但是立体感较差</p></li><li><p>侧光：从侧面照射被摄物体的光，明暗变化比较好，会使画面有一种很强的立体感和造型感，适合人像摄影–&gt;可以更直观的体现人物的情绪和性格</p></li><li><p>逆光：从被摄物体订单背面照射的光，又称轮廓光，可以强调被摄主体的轮廓和线条感</p></li><li><p>顶光：从顶部直射的光，如果在顶光条件下拍摄人物，会产生大面积的奇特阴影效果，不利于塑造美感</p><img src="/hexoblog.github.io/2022/07/10/%E8%B0%88%E8%B0%88%E6%91%84%E5%BD%B1%E4%B8%AD%E7%9A%84%E5%85%89%E7%BA%BF/%E5%85%89%E7%9A%84%E6%96%B9%E5%90%91.JPG" class title="This is an 方向 image"></li></ul><h2 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h2><ul><li><p>硬光：泛指直接照射的光，容易形成强烈阴影，如舞台的追光灯，一般避免用于拍人像</p></li><li><p>柔光：一般指非直射的光线，光线通过一定阻挡再散发出来的光，例如阴天的情况，相对柔和，适合人像拍摄</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 光线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测光和对焦</title>
      <link href="/hexoblog.github.io/2022/07/10/%E6%B5%8B%E5%85%89%E5%92%8C%E5%AF%B9%E7%84%A6/"/>
      <url>/hexoblog.github.io/2022/07/10/%E6%B5%8B%E5%85%89%E5%92%8C%E5%AF%B9%E7%84%A6/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="测光"><a href="#测光" class="headerlink" title="测光"></a>测光</h2><h3 id="评价测光：矩阵测光，常用，适用于多数场景，结合画面中各部分光线情况给出合适的曝光值（适合风光，人像）"><a href="#评价测光：矩阵测光，常用，适用于多数场景，结合画面中各部分光线情况给出合适的曝光值（适合风光，人像）" class="headerlink" title="评价测光：矩阵测光，常用，适用于多数场景，结合画面中各部分光线情况给出合适的曝光值（适合风光，人像）"></a>评价测光：矩阵测光，常用，适用于多数场景，结合画面中各部分光线情况给出合适的曝光值（适合风光，人像）</h3> <ol><li><p>点测光：选取画面中1%-3%的区域作为测光对象，常用于拍剪影等大光比画面</p></li><li><p>局部测光：选取画面中9%的区域作为测光对象，它的测光对象只有画面中心的一部份区域，不够灵活，较少用</p></li><li><p>中央重点测光：在局部测光模式的基础上兼顾中心四周其他区域</p></li></ol><h2 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h2><h3 id="手动对焦：手动转动镜头对焦环进行对焦"><a href="#手动对焦：手动转动镜头对焦环进行对焦" class="headerlink" title="手动对焦：手动转动镜头对焦环进行对焦"></a>手动对焦：手动转动镜头对焦环进行对焦</h3><h3 id="自动对焦："><a href="#自动对焦：" class="headerlink" title="自动对焦："></a>自动对焦：</h3><ol><li><p>AF-S：单次自动对焦，完成对焦后，半按快门不放，则对焦点不变，<strong>常用于拍静止物体</strong></p></li><li><p>AF-C：，半按快门状态下，对焦点会持续对焦，<strong>常用于拍摄运动物体</strong></p></li><li><p>AF-A：AF-S和AF-C结合，相机根据被摄物体是否运动而自动在AF-S和AF-C之间切换模式</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ·对焦 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相机参数</title>
      <link href="/hexoblog.github.io/2022/07/10/%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0/"/>
      <url>/hexoblog.github.io/2022/07/10/%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="相机存储模式"><a href="#相机存储模式" class="headerlink" title="相机存储模式"></a>相机存储模式</h2><ul><li><p>JPEG:常用相片存储格式，直出常用，有损压缩，非原始数据，后期空间较小</p></li><li><p>RAW：未经处理和压缩的原始数据，后期空间大，文件较大</p></li></ul><h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h2> <img src="/hexoblog.github.io/2022/07/10/%E7%9B%B8%E6%9C%BA%E5%8F%82%E6%95%B0/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4.png" class title="This is an 色彩空间 image"><ul><li><p>SRGB：常用，大部分显示器的色彩标准，网络传播可用此参数</p></li><li><p>Adobe EGB：少用，常用于打印、印刷出版等，再常用显示器上显示会有色差</p></li></ul><h2 id="白平衡（相机上表示AWB，单位是K）"><a href="#白平衡（相机上表示AWB，单位是K）" class="headerlink" title="白平衡（相机上表示AWB，单位是K）"></a>白平衡（相机上表示AWB，单位是K）</h2><ul><li><p>还原被摄物体再不同光线下的原有色彩，使其与人眼所见相近，简而言之，就是无论环境光线如何影响白色，相机仍然能还原”白色”的一种功能</p></li><li><p>k值越大，色调越暖，适合拍摄温暖、安静氛围；k值越小，色调越冷，适合拍摄清冷情绪（具体视情况而定，仅供参考）：</p></li></ul><h2 id="相片风格："><a href="#相片风格：" class="headerlink" title="相片风格："></a>相片风格：</h2><h3 id="种类："><a href="#种类：" class="headerlink" title="种类："></a>种类：</h3><ol><li><p>标准：对相片做轻微的处理适当提高饱和度和锐度</p></li><li><p>人像：注重肤色的表现，进行轻微的锐化</p></li><li><p>风光：强化蓝色和绿色，进行较大幅度锐化</p></li><li><p>单色：将相片转为黑色</p></li></ol><h4 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h4><ol><li><p>锐度：可以理解为相片的清晰度，锐度高则清晰锐利，反之柔和</p></li><li><p>反差：相片的明暗对比，反差大则对比度高，色彩鲜艳，反之灰蒙暗淡</p></li><li><p>饱和度：相片中的色彩的鲜艳程度，饱和度高则色彩鲜艳，反之暗淡</p></li><li><p>色调：相片中颜色的整体倾向，增加色调则偏黄，反之偏红</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ·相片格式 ·饱和度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目中的业务处理--软删除和硬删除</title>
      <link href="/hexoblog.github.io/2022/07/09/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86-%E8%BD%AF%E5%88%A0%E9%99%A4%E5%92%8C%E7%A1%AC%E5%88%A0%E9%99%A4/"/>
      <url>/hexoblog.github.io/2022/07/09/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86-%E8%BD%AF%E5%88%A0%E9%99%A4%E5%92%8C%E7%A1%AC%E5%88%A0%E9%99%A4/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="硬删除"><a href="#硬删除" class="headerlink" title="#硬删除"></a>#硬删除</h1><h3 id="定义：硬删除就是传统的物理删除，直接将记录从数据库中删除"><a href="#定义：硬删除就是传统的物理删除，直接将记录从数据库中删除" class="headerlink" title="定义：硬删除就是传统的物理删除，直接将记录从数据库中删除"></a>定义：硬删除就是传统的物理删除，直接将记录从数据库中删除</h3><ul><li><p>例如：在我们之前写程序的时候,经常需要删除一条记录,删除语句则是:delete from table where condition&#x3D;conditionValue </p></li><li><p>这个时候,在数据库中是真正意义上的删除,你没法再通过select语句查出来,而这个做法,就叫硬删除</p></li></ul><h3 id="缺点：容易误操作从而删除重要的数据，如果想要恢复该数据，需要锁表再去访问日志文件，但是这样可能会造成大量的人力资源浪费（不言多喻，没有后悔药）"><a href="#缺点：容易误操作从而删除重要的数据，如果想要恢复该数据，需要锁表再去访问日志文件，但是这样可能会造成大量的人力资源浪费（不言多喻，没有后悔药）" class="headerlink" title="缺点：容易误操作从而删除重要的数据，如果想要恢复该数据，需要锁表再去访问日志文件，但是这样可能会造成大量的人力资源浪费（不言多喻，没有后悔药）"></a>缺点：容易误操作从而删除重要的数据，如果想要恢复该数据，需要锁表再去访问日志文件，但是这样可能会造成大量的人力资源浪费（不言多喻，没有后悔药）</h3><h3 id="优点：去除部分冗杂数据，节省空间"><a href="#优点：去除部分冗杂数据，节省空间" class="headerlink" title="优点：去除部分冗杂数据，节省空间"></a>优点：去除部分冗杂数据，节省空间</h3><ul><li>例如：这里有一个商品表，和一些相关的订单信息表，然后订单表是关联到商品id的，这个时候如果直接将这个商品删除，就会导致订单查不出这个商品信息。</li></ul><h1 id="软删除"><a href="#软删除" class="headerlink" title="#软删除"></a>#软删除</h1><h3 id="定义：可以叫做逻辑删除、标记删除我们常说的删除不同，并不是真的从数据库中将这条记录去除，而是会设置一个字段，isDelete或者status字段，标识该条记录是否被删除"><a href="#定义：可以叫做逻辑删除、标记删除我们常说的删除不同，并不是真的从数据库中将这条记录去除，而是会设置一个字段，isDelete或者status字段，标识该条记录是否被删除" class="headerlink" title="定义：可以叫做逻辑删除、标记删除我们常说的删除不同，并不是真的从数据库中将这条记录去除，而是会设置一个字段，isDelete或者status字段，标识该条记录是否被删除"></a>定义：可以叫做逻辑删除、标记删除我们常说的删除不同，并不是真的从数据库中将这条记录去除，而是会设置一个字段，isDelete或者status字段，标识该条记录是否被删除</h3><ul><li>例如目前软删除的做法：(<a href="https://www.jianshu.com/p/889365078e24">https://www.jianshu.com/p/889365078e24</a>)</li></ul><ol><li>在表内加 isDeleted bool</li><li>在表内添加 deleted_at timestamp (可以为null) (gem gorm这类orm框架支持)</li><li>删除数据 存储到 因为一个表内</li></ol><p>第二种方式最差 因为字段可以为null 会导致查询效率大打折扣。更重要的情况 会导致 全表扫描 如果数据量偏大会遇到性能瓶颈</p><h3 id="缺点：会导致查数据慢（https-ruby-china-org-topics-34540）"><a href="#缺点：会导致查数据慢（https-ruby-china-org-topics-34540）" class="headerlink" title="缺点：会导致查数据慢（https://ruby-china.org/topics/34540）"></a>缺点：会导致查数据慢（<a href="https://ruby-china.org/topics/34540%EF%BC%89">https://ruby-china.org/topics/34540）</a></h3>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IsDelete </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git学习</title>
      <link href="/hexoblog.github.io/2022/07/07/git%E7%AF%87-%E4%B8%8A%E4%BC%A0%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%96%B0/"/>
      <url>/hexoblog.github.io/2022/07/07/git%E7%AF%87-%E4%B8%8A%E4%BC%A0%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="初次体验："><a href="#初次体验：" class="headerlink" title="初次体验："></a>初次体验：</h2><h3 id="git上传步骤：-仅第一次上传可参考"><a href="#git上传步骤：-仅第一次上传可参考" class="headerlink" title="git上传步骤：(仅第一次上传可参考)"></a>git上传步骤：(仅第一次上传可参考)</h3><ol><li><p>登录github账号，新建仓库；</p></li><li><p>无错误然后 使用git bash打开本地项目的文件夹，然后执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>(初始化git)</p></li><li><p>无错误然后 复制新建仓库的SSH地址，继续执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin SSH地址(粘贴)</span><br></pre></td></tr></table></figure><p>(SSH地址为所提交的仓库地址)</p></li><li><p>无错误然后 继续执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>(“.”代表所有 可用文件名代替”.” 来上传某个文件)<br>(这是添加要提交的本地项目)</p></li><li><p>无错误然后 继续执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;上传描述&quot;</span><br></pre></td></tr></table></figure><p>(提交到本地库)</p></li><li><p>无错误然后 继续执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master(main)</span><br></pre></td></tr></table></figure><p>(将该项目推送到gitlab端)</p></li></ol><hr><h3 id="可能会遇到的错误01-推送命令发出后，若出现：-failed-to-push-some-refs-to-git-错误，主要原因是github中的README-md文件不在本地代码目录中，因此，可通过如下命令进行代码合并（pull-x3D-fetch-merge）"><a href="#可能会遇到的错误01-推送命令发出后，若出现：-failed-to-push-some-refs-to-git-错误，主要原因是github中的README-md文件不在本地代码目录中，因此，可通过如下命令进行代码合并（pull-x3D-fetch-merge）" class="headerlink" title="可能会遇到的错误01:推送命令发出后，若出现：  failed to push some refs to git 错误，主要原因是github中的README.md文件不在本地代码目录中，因此，可通过如下命令进行代码合并（pull&#x3D;fetch+merge）:"></a>可能会遇到的错误01:推送命令发出后，若出现：  failed to push some refs to git 错误，主要原因是github中的README.md文件不在本地代码目录中，因此，可通过如下命令进行代码合并（pull&#x3D;fetch+merge）:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">it pull --rebase origin master</span><br></pre></td></tr></table></figure><h3 id="执行完此代码后可以看到本地代码库多了README-MD文件，此时，再执行语句："><a href="#执行完此代码后可以看到本地代码库多了README-MD文件，此时，再执行语句：" class="headerlink" title="执行完此代码后可以看到本地代码库多了README.MD文件，此时，再执行语句："></a>执行完此代码后可以看到本地代码库多了README.MD文件，此时，再执行语句：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master </span><br></pre></td></tr></table></figure><hr><h2 id="熟练操作"><a href="#熟练操作" class="headerlink" title="熟练操作"></a>熟练操作</h2><h3 id="git更新或者在同一个仓库上传新内容–-gt-步骤："><a href="#git更新或者在同一个仓库上传新内容–-gt-步骤：" class="headerlink" title="git更新或者在同一个仓库上传新内容–&gt;步骤："></a>git更新或者在同一个仓库上传新内容–&gt;步骤：</h3><ol><li><p>git bash 已经初始化的仓库，执行： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>或者只是添加某个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure></li><li><p>无错误，继续执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;更新描述&quot;</span><br></pre></td></tr></table></figure></li><li><p>无错误，然后再push上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ol><img src="/hexoblog.github.io/2022/07/07/git%E7%AF%87-%E4%B8%8A%E4%BC%A0%E4%BB%A5%E5%8F%8A%E6%9B%B4%E6%96%B0/%E6%9B%B4%E6%96%B0.png" class title="This is an update image"><h2 id="可能会遇到的错误02：如果出现端口拒绝，类似：”ssh-connect-to-host-github-com-port-22-Connection-refused”-可以尝试关闭加速器-vpn-然后再试试"><a href="#可能会遇到的错误02：如果出现端口拒绝，类似：”ssh-connect-to-host-github-com-port-22-Connection-refused”-可以尝试关闭加速器-vpn-然后再试试" class="headerlink" title="可能会遇到的错误02：如果出现端口拒绝，类似：”ssh: connect to host github.com port 22: Connection refused”,可以尝试关闭加速器(vpn),然后再试试"></a>可能会遇到的错误02：如果出现端口拒绝，类似：”ssh: connect to host github.com port 22: Connection refused”,可以尝试关闭加速器(vpn),然后再试试</h2><h2 id="进阶知识"><a href="#进阶知识" class="headerlink" title="进阶知识:"></a>进阶知识:</h2><ul><li>git init：仓库初始化(个人仓库)。</li><li>git init –bare：仓库初始化(共享仓库)。</li><li>git status：查文件的状态。</li><li>git log：查看文件的修改日志。</li><li>git diff：查看文件最新改动的地方。</li><li>git rm：删除文件（删完之后要进行commit操作，才能同步到版本库）。</li><li>git reset：版本回退。</li><li>git clone：下载远程仓库到本地。</li><li>git pull：下载远程仓库的最新信息到本地仓库。</li><li>git push：将本地的仓库信息推送到远程仓库。</li><li>git branch：查看所有分支。</li><li>git branch 分支名称：创建分支。</li><li>git checkout 分支名称：切换到指定分支。</li><li>git merge 分支名称：将当前所在分支和指定名称分支进行合并。</li><li>git branch -d 分支名称： 删除指定分支。</li></ul>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言基础--查漏补缺</title>
      <link href="/hexoblog.github.io/2022/07/05/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/"/>
      <url>/hexoblog.github.io/2022/07/05/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="25个关键词"><a href="#25个关键词" class="headerlink" title="#25个关键词"></a>#25个关键词</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">break    default      func    interface    select</span><br><span class="line">case     defer        go      map          struct</span><br><span class="line">chan     else         goto    package      switch</span><br><span class="line">const    fallthrough  if      range        type</span><br><span class="line">continue for          import  return       var</span><br></pre></td></tr></table></figure><p> –来源于W3Cschool–Go web编程</p><hr><h2 id="Go程序是通过package来组织的"><a href="#Go程序是通过package来组织的" class="headerlink" title="#Go程序是通过package来组织的"></a>#Go程序是通过package来组织的</h2><ul><li><p>每一个可独立运行的Go程序，必定包含一个package main，在这个main包中必定包含一个入口函数main，而这个函数既没有参数，也没有返回值。</p></li><li><p>Go是天生支持UTF-8的(字符串都是采用UTF-8字符集编码 )，<strong>任何字符都可以直接输出</strong>，你甚至可以用UTF-8中的任何字符作为标识符</p></li></ul><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="x3D-符号只能在函数内部使用，在函数外部使用则无法编译通过"><a href="#x3D-符号只能在函数内部使用，在函数外部使用则无法编译通过" class="headerlink" title="# :&#x3D;符号只能在函数内部使用，在函数外部使用则无法编译通过"></a># :&#x3D;符号只能在函数内部使用，在函数外部使用则无法编译通过</h2><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="已声明但未使用的变量会在编译阶段报错"><a href="#已声明但未使用的变量会在编译阶段报错" class="headerlink" title="#已声明但未使用的变量会在编译阶段报错"></a>#已声明但未使用的变量会在编译阶段报错</h2><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="Go-常量和一般程序语言不同的是，可以指定相当多的小数位数-例如200位-，-若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit"><a href="#Go-常量和一般程序语言不同的是，可以指定相当多的小数位数-例如200位-，-若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit" class="headerlink" title="#Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)， 若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit"></a>#Go 常量和一般程序语言不同的是，可以指定相当多的小数位数(例如200位)， 若指定給float32自动缩短为32bit，指定给float64自动缩短为64bit</h2><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="make用于内建类型（map、slice-和channel）的内存分配。new用于各种类型的内存分配："><a href="#make用于内建类型（map、slice-和channel）的内存分配。new用于各种类型的内存分配：" class="headerlink" title="#make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配："></a>#make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配：</h2><img src="/hexoblog.github.io/2022/07/05/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98.png" class title="分配内存"><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="new-T-分配了零值填充的T类型的内存空间，它返回了一个指针，指向新分配的类型T的零值"><a href="#new-T-分配了零值填充的T类型的内存空间，它返回了一个指针，指向新分配的类型T的零值" class="headerlink" title="#new(T)分配了零值填充的T类型的内存空间，它返回了一个指针，指向新分配的类型T的零值"></a>#new(T)分配了零值填充的T类型的内存空间，它返回了一个指针，指向新分配的类型T的零值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new 返回指针</span><br></pre></td></tr></table></figure><p>make和new的区别：</p><img src="/hexoblog.github.io/2022/07/05/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/new%E5%92%8Cmake.png" class title="new和make"><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="goto语句的标签名大小写是敏感的"><a href="#goto语句的标签名大小写是敏感的" class="headerlink" title="#goto语句的标签名大小写是敏感的"></a>#goto语句的标签名大小写是敏感的</h2><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="go语言没有while关键词，但是"><a href="#go语言没有while关键词，但是" class="headerlink" title="#go语言没有while关键词，但是:"></a>#go语言没有while关键词，但是:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := 1</span><br><span class="line">for ; sum &lt; 1000;  &#123;</span><br><span class="line">    sum += sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如上，可以像这样构建一个while循环功能"><a href="#如上，可以像这样构建一个while循环功能" class="headerlink" title="如上，可以像这样构建一个while循环功能"></a>如上，可以像这样构建一个while循环功能</h3><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="swith-case-我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch-但是可以使用fallthrough强制执行后面的case代码。"><a href="#swith-case-我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch-但是可以使用fallthrough强制执行后面的case代码。" class="headerlink" title="#(swith case):我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。:"></a>#(swith case):我们把很多值聚合在了一个case里面，同时，Go里面switch默认相当于每个case最后带有break，匹配成功后不会自动向下执行其他case，而是跳出整个switch, 但是可以使用fallthrough强制执行后面的case代码。:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">integer := 6</span><br><span class="line">switch integer &#123;</span><br><span class="line">    case 4:</span><br><span class="line">    fmt.Println(&quot;The integer was &lt;= 4&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">    case 5:</span><br><span class="line">    fmt.Println(&quot;The integer was &lt;= 5&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">    case 6:</span><br><span class="line">    fmt.Println(&quot;The integer was &lt;= 6&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">    case 7:</span><br><span class="line">    fmt.Println(&quot;The integer was &lt;= 7&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">    case 8:</span><br><span class="line">    fmt.Println(&quot;The integer was &lt;= 8&quot;)</span><br><span class="line">    fallthrough</span><br><span class="line">    default:</span><br><span class="line">    fmt.Println(&quot;default case&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上面程序的结果"><a href="#上面程序的结果" class="headerlink" title="上面程序的结果"></a>上面程序的结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The integer was &lt;= 6</span><br><span class="line">The integer was &lt;= 7</span><br><span class="line">The integer was &lt;= 8</span><br><span class="line">default case</span><br></pre></td></tr></table></figure><p>–来源于W3Cschool–Go web编程</p><hr><h2 id="程序执行过程：main包中的其他被导入的包–-gt-包中的包级常量和变量初始化–-gt-init函数-如果有的话-–-gt-包加载完后就对main中的包级常量和变量进行初始化，然后执行main包中的init函数–-gt-最后执行main中的函数："><a href="#程序执行过程：main包中的其他被导入的包–-gt-包中的包级常量和变量初始化–-gt-init函数-如果有的话-–-gt-包加载完后就对main中的包级常量和变量进行初始化，然后执行main包中的init函数–-gt-最后执行main中的函数：" class="headerlink" title="#程序执行过程：main包中的其他被导入的包–&gt;包中的包级常量和变量初始化–&gt;init函数(如果有的话)–&gt;包加载完后就对main中的包级常量和变量进行初始化，然后执行main包中的init函数–&gt;最后执行main中的函数："></a>#程序执行过程：main包中的其他被导入的包–&gt;包中的包级常量和变量初始化–&gt;init函数(如果有的话)–&gt;包加载完后就对main中的包级常量和变量进行初始化，然后执行main包中的init函数–&gt;最后执行main中的函数：</h2><p>{ % asset_img 程序执行过程.png 程序执行过程 % }<br>–来源于W3Cschool–Go web编程</p><hr>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go语言基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GO语言参数校验</title>
      <link href="/hexoblog.github.io/2022/07/04/GO%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/hexoblog.github.io/2022/07/04/GO%E8%AF%AD%E8%A8%80%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在服务器中需要接收前端发送过来的请求并且进行处理，而这些请求往往是附带参数的，所以对参数的处理是非常重要的一环</p><h2 id="何为参数校验？"><a href="#何为参数校验？" class="headerlink" title="何为参数校验？"></a>何为参数校验？</h2><p>顾名思义就是对请求所附带的参数进行验证（可以理解为后端对前端所发送的数据的进一步筛选处理，然后返回对应的逻辑）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://www.baidu.com/s?ie=UTF-8&amp;wd=JSR303</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面这段请求中，”?”后面的内容就是参数(参数是以键值对的形式出现)，还有的参数并不会出现在url当中，他们会包含在请求体当中，通过url是看不到的。</p><h2 id="goland参数校验"><a href="#goland参数校验" class="headerlink" title="goland参数校验"></a>goland参数校验</h2><h3 id="常见的参数校验可以分为以下两种："><a href="#常见的参数校验可以分为以下两种：" class="headerlink" title="常见的参数校验可以分为以下两种："></a>常见的参数校验可以分为以下两种：</h3><ul><li><p>客户端参数校验：在数据提交到服务器之前，发生在浏览器端或者app应用端，相比服务器端校验，用户体验更好，能实时反馈用户的输入校验结果。</p></li><li><p>服务器端参数校验：发生在客户端提交数据并被服务器端程序接收之后，通常服务器端校验都是发生在将数据写入数据库之前，如果数据没通过校验，则会直接从服务器端返回错误消息，并且告诉客户端发生错误的具体位置和原因，服务器端校验不像客户端校验那样有好的用户体验，因为它直到整个表单都提交后才能返回错误信息。但是服务器端校验是应用对抗错误，恶意数据的最后防线，在这之后，数据将被持久化至数据库。当今所有的服务端框架都提供了数据校验与过滤功能（让数据更安全）。</p></li></ul><h3 id="针对服务器-go语言参数校验的三种方式："><a href="#针对服务器-go语言参数校验的三种方式：" class="headerlink" title="针对服务器-go语言参数校验的三种方式："></a>针对服务器-go语言参数校验的三种方式：</h3><ol><li><p>第一种实现方式：自定义实现参数校验逻辑<br><strong>Controller层职责：从HTTP请求中获得信息，提取参数，并分发给不同的处理服务。</strong><br><strong>重复代码是软件质量下降的重大来源</strong></p></li><li><p>第二种实现方式：模型绑定校验–go-playground &#x2F; validator–一款优秀的Go语言校验库，基于标记为结构体和单个字段实现值验证。使用简单、快捷–&gt;结构体验证示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/go-playground/validator</span><br></pre></td></tr></table></figure></li></ol><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/go-playground/validator&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">var validate *validator.Validate //定义</span><br><span class="line"> </span><br><span class="line">type User struct &#123;</span><br><span class="line">Name  string `validate:&quot;required&quot;` //非空</span><br><span class="line">Age   uint8  `validate:&quot;gte=0,lte=130&quot;` //  0&lt;=Age&lt;=130</span><br><span class="line">Email string `validate:&quot;required,email&quot;` //非空，email格式</span><br><span class="line">//dive关键字代表 进入到嵌套结构体进行判断</span><br><span class="line">Address []*Address `validate:&quot;dive&quot;` //  可以拥有多个地址</span><br><span class="line">&#125;</span><br><span class="line">type Address struct &#123;</span><br><span class="line">Province string `validate:&quot;required&quot;` //非空</span><br><span class="line">City     string `validate:&quot;required&quot;` //非空</span><br><span class="line">Phone    string `validate:&quot;numeric,len=11&quot;` //数字类型，长度为11</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">validate = validator.New() //初始化（赋值）</span><br><span class="line">validateStruct()           //结构体校验</span><br><span class="line">validateVariable()         //变量校验</span><br><span class="line">&#125;</span><br><span class="line">func validateStruct() &#123;</span><br><span class="line">address := Address&#123;</span><br><span class="line">Province: &quot;重庆&quot;,</span><br><span class="line">City:     &quot;重庆&quot;,</span><br><span class="line">Phone:    &quot;13366663333x&quot;,</span><br><span class="line">&#125;</span><br><span class="line">user := User&#123;</span><br><span class="line">Name:  &quot;江洲&quot;,</span><br><span class="line">Age:   23,</span><br><span class="line">Email: &quot;jz@163.com&quot;,</span><br><span class="line">Address: []*Address&#123;&amp;address&#125;,</span><br><span class="line">&#125;</span><br><span class="line">err := validate.Struct(user)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">//断言为：validator.ValidationErrors，类型为：[]FieldError</span><br><span class="line">for _, e := range err.(validator.ValidationErrors) &#123;</span><br><span class="line">fmt.Println(&quot;Namespace:&quot;, e.Namespace())</span><br><span class="line">fmt.Println(&quot;Field:&quot;, e.Field())</span><br><span class="line">fmt.Println(&quot;StructNamespace:&quot;, e.StructNamespace())</span><br><span class="line">fmt.Println(&quot;StructField:&quot;, e.StructField())</span><br><span class="line">fmt.Println(&quot;Tag:&quot;, e.Tag())</span><br><span class="line">fmt.Println(&quot;ActualTag:&quot;, e.ActualTag())</span><br><span class="line">fmt.Println(&quot;Kind:&quot;, e.Kind())</span><br><span class="line">fmt.Println(&quot;Type:&quot;, e.Type())</span><br><span class="line">fmt.Println(&quot;Value:&quot;, e.Value())</span><br><span class="line">fmt.Println(&quot;Param:&quot;, e.Param())</span><br><span class="line">fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">fmt.Println(&quot;结构体输入数据类型错误！&quot;)</span><br><span class="line">return</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;结构体校验通过&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//变量校验</span><br><span class="line">func validateVariable() &#123;</span><br><span class="line">myEmail := &quot;123@qq.com&quot; //邮箱地址：xx@xx.com</span><br><span class="line">err := validate.Var(myEmail, &quot;required,email&quot;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">fmt.Println(&quot;变量校验通过！&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="结果"><a href="#结果" class="headerlink" title="结果:"></a>结果:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Namespace: User.Address[0].Phone</span><br><span class="line">Field: phone</span><br><span class="line">StructNamespace: User.Address[0].Phone</span><br><span class="line">StructFiled: Phone</span><br><span class="line">Tag: numeric</span><br><span class="line">ActualTag: numeric</span><br><span class="line">Kind: string</span><br><span class="line">Type: string</span><br><span class="line">Value: 13366663333x</span><br><span class="line">Param:</span><br><span class="line"></span><br><span class="line">结构体输入数据类型错误！</span><br><span class="line">变量校验通过！</span><br></pre></td></tr></table></figure><h5 id="模型校验是通过反射机制来实现的，而反射效率相对来说效率不高-可以从ShouldBind函数从下追，把自带的校验功能屏蔽，提高框架效率"><a href="#模型校验是通过反射机制来实现的，而反射效率相对来说效率不高-可以从ShouldBind函数从下追，把自带的校验功能屏蔽，提高框架效率" class="headerlink" title="模型校验是通过反射机制来实现的，而反射效率相对来说效率不高(可以从ShouldBind函数从下追，把自带的校验功能屏蔽，提高框架效率???!!!)"></a><strong>模型校验是通过反射机制来实现的，而反射效率相对来说效率不高(可以从ShouldBind函数从下追，把自带的校验功能屏蔽，提高框架效率???!!!)</strong></h5><ol start="3"><li>第三种实现方式：拆解模型字段，组合结构体</li></ol><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://juejin.cn/post/7041508590913323039">https://juejin.cn/post/7041508590913323039</a><br><a href="https://blog.csdn.net/weixin_42117918/article/details/107407053">https://blog.csdn.net/weixin_42117918/article/details/107407053</a></p>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust踩坑日记01</title>
      <link href="/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/"/>
      <url>/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="入坑Rust第一天"><a href="#入坑Rust第一天" class="headerlink" title="入坑Rust第一天"></a>入坑Rust第一天</h2><p>先把Rustc工具下载好之后，然后执行rustinit.exe程序安装rust,安装过程中，系统提示需要c&#x2F;c++ build tools，于是在微软商店下载Visual Studio，安装下载c&#x2F;c++桌面配置程序，大概4g左右，(因为MinGW之前配置Goland已经下载好了)</p><h3 id="然后开始使用vscode搭建rust环境，下载好相关的语言包和调试工具，发现运行时遇到了一个困扰大半天的问题（rustc和cargo编译均有问题）："><a href="#然后开始使用vscode搭建rust环境，下载好相关的语言包和调试工具，发现运行时遇到了一个困扰大半天的问题（rustc和cargo编译均有问题）：" class="headerlink" title="然后开始使用vscode搭建rust环境，下载好相关的语言包和调试工具，发现运行时遇到了一个困扰大半天的问题（rustc和cargo编译均有问题）："></a>然后开始使用vscode搭建rust环境，下载好相关的语言包和调试工具，发现运行时遇到了一个困扰大半天的问题（rustc和cargo编译均有问题）：</h3><img src="/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/rustbug01.png" class title="This is an rustBug image"><img src="/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/rustbug02.png" class title="This is an rustBug image"><h3 id="后来发现是使用的MinGW不对（发现是包的问题），使用的MinGW需要是seh版本的，而非sjlj版本，如下："><a href="#后来发现是使用的MinGW不对（发现是包的问题），使用的MinGW需要是seh版本的，而非sjlj版本，如下：" class="headerlink" title="后来发现是使用的MinGW不对（发现是包的问题），使用的MinGW需要是seh版本的，而非sjlj版本，如下："></a>后来发现是使用的MinGW不对（发现是包的问题），使用的MinGW需要是seh版本的，而非sjlj版本，如下：</h3><img src="/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" class title="This is an solotionTest image"><h3 id="下载后-速度有点慢-，使用rustc和cargo进行编译–-gt-问题得到解决："><a href="#下载后-速度有点慢-，使用rustc和cargo进行编译–-gt-问题得到解决：" class="headerlink" title="下载后(速度有点慢)，使用rustc和cargo进行编译–&gt;问题得到解决："></a>下载后(速度有点慢)，使用rustc和cargo进行编译–&gt;问题得到解决：</h3><img src="/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/rust%E8%A7%A3%E5%86%B301.png" class title="This is an solution image"><img src="/hexoblog.github.io/2022/07/04/Rust%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B001/rust%E8%A7%A3%E5%86%B302.png" class title="This is an solution image">]]></content>
      
      
      <categories>
          
          <category> Rust语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习01--环境检查基础篇</title>
      <link href="/hexoblog.github.io/2022/07/02/Rust%E5%AD%A6%E4%B9%A001--%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5%E5%9F%BA%E7%A1%80%E7%AF%87/"/>
      <url>/hexoblog.github.io/2022/07/02/Rust%E5%AD%A6%E4%B9%A001--%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="命令行环境检查以及简单rustc和cargo命令（配置环境以及安装rust网上超多教程）"><a href="#命令行环境检查以及简单rustc和cargo命令（配置环境以及安装rust网上超多教程）" class="headerlink" title="命令行环境检查以及简单rustc和cargo命令（配置环境以及安装rust网上超多教程）"></a>命令行环境检查以及简单rustc和cargo命令（配置环境以及安装rust网上超多教程）</h1><h2 id="验证Cargo包管理器安装"><a href="#验证Cargo包管理器安装" class="headerlink" title="验证Cargo包管理器安装"></a>验证Cargo包管理器安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo --version</span><br></pre></td></tr></table></figure><h2 id="验证rustc编译工具安装"><a href="#验证rustc编译工具安装" class="headerlink" title="验证rustc编译工具安装"></a>验证rustc编译工具安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc --version</span><br></pre></td></tr></table></figure><h2 id="查看rustc的版本"><a href="#查看rustc的版本" class="headerlink" title="查看rustc的版本"></a>查看rustc的版本</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc -V</span><br></pre></td></tr></table></figure><h2 id="查看rustc的基本用法"><a href="#查看rustc的基本用法" class="headerlink" title="查看rustc的基本用法"></a>查看rustc的基本用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc -h</span><br></pre></td></tr></table></figure><h2 id="查看cargo的基本用法"><a href="#查看cargo的基本用法" class="headerlink" title="查看cargo的基本用法"></a>查看cargo的基本用法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo -h</span><br></pre></td></tr></table></figure><h2 id="使用rustc编译rs文件-编译成功后会生成一个二进制的可执行文件，运行这个main可执行文件"><a href="#使用rustc编译rs文件-编译成功后会生成一个二进制的可执行文件，运行这个main可执行文件" class="headerlink" title="使用rustc编译rs文件,编译成功后会生成一个二进制的可执行文件，运行这个main可执行文件"></a>使用rustc编译rs文件,编译成功后会生成一个二进制的可执行文件，运行这个main可执行文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs //编译</span><br><span class="line">./main.rs //运行</span><br></pre></td></tr></table></figure><h2 id="使用cargo工具，新建一个rustprojects文件夹，命令行打开运行如下代码："><a href="#使用cargo工具，新建一个rustprojects文件夹，命令行打开运行如下代码：" class="headerlink" title="使用cargo工具，新建一个rustprojects文件夹，命令行打开运行如下代码："></a>使用cargo工具，新建一个rustprojects文件夹，命令行打开运行如下代码：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new xxx //xxx为包名</span><br></pre></td></tr></table></figure><p>成功后会有一个项目结构出现：</p><img src="/hexoblog.github.io/2022/07/02/Rust%E5%AD%A6%E4%B9%A001--%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5%E5%9F%BA%E7%A1%80%E7%AF%87/new.png" class title="This is an cargo new image"><h4 id="继续执行："><a href="#继续执行：" class="headerlink" title="继续执行："></a>继续执行：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run main.rs</span><br></pre></td></tr></table></figure><p>成功执行(new一个包的时候系统会自动在main.rs文件内写入一段打印”Hello world”的程序)</p><img src="/hexoblog.github.io/2022/07/02/Rust%E5%AD%A6%E4%B9%A001--%E7%8E%AF%E5%A2%83%E6%A3%80%E6%9F%A5%E5%9F%BA%E7%A1%80%E7%AF%87/run.png" class title="This is an cargo run image">]]></content>
      
      
      <categories>
          
          <category> Rust语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ·rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言错误处理</title>
      <link href="/hexoblog.github.io/2022/07/01/Go%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/hexoblog.github.io/2022/07/01/Go%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="go语言中错误处理方式为："><a href="#go语言中错误处理方式为：" class="headerlink" title="go语言中错误处理方式为："></a>go语言中错误处理方式为：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic()-defer-recover()</span><br></pre></td></tr></table></figure><h4 id="Go语言中可以使用panic-函数抛出一个错误，然后在defer中通过recover-函数捕获异常进程后续处理。"><a href="#Go语言中可以使用panic-函数抛出一个错误，然后在defer中通过recover-函数捕获异常进程后续处理。" class="headerlink" title="Go语言中可以使用panic()函数抛出一个错误，然后在defer中通过recover()函数捕获异常进程后续处理。"></a>Go语言中可以使用panic()函数抛出一个错误，然后在defer中通过recover()函数捕获异常进程后续处理。</h4><h3 id="panic"><a href="#panic" class="headerlink" title="panic()"></a>panic()</h3><ul><li>go语言的内置函数，用于抛出错误，定义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func panic(v interface &#123;&#125;)</span><br></pre></td></tr></table></figure></li><li>请注意，如果单独只使用panic()对错误进行抛出，后续程序将终止执行</li></ul><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><h4 id="defer是go语言的预留关键字，用于延迟执行函数的执行。通常在资源释放、链接关闭、函数结束时调用。多个defer为堆栈结构，后进先出，并且在压栈时不能有未知变量或函数，defer在此可用于异常抛出后的处理。"><a href="#defer是go语言的预留关键字，用于延迟执行函数的执行。通常在资源释放、链接关闭、函数结束时调用。多个defer为堆栈结构，后进先出，并且在压栈时不能有未知变量或函数，defer在此可用于异常抛出后的处理。" class="headerlink" title="defer是go语言的预留关键字，用于延迟执行函数的执行。通常在资源释放、链接关闭、函数结束时调用。多个defer为堆栈结构，后进先出，并且在压栈时不能有未知变量或函数，defer在此可用于异常抛出后的处理。"></a>defer是go语言的预留关键字，用于延迟执行函数的执行。通常在资源释放、链接关闭、函数结束时调用。<strong>多个defer为堆栈结构</strong>，后进先出，<strong>并且在压栈时不能有未知变量或函数</strong>，<code>defer</code>在此可用于异常抛出后的处理。</h4><h2 id="recover"><a href="#recover" class="headerlink" title="recover()"></a>recover()</h2><ul><li>go语言的内置函数，用于获取异常，<strong>多次调用时只有第一次能获取值</strong>，定义：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func recover() interface&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li><p>err1.go代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package errlab</span><br><span class="line"> </span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"> </span><br><span class="line">//defer recover 来处理错误</span><br><span class="line"> </span><br><span class="line">func Testerr()&#123;</span><br><span class="line">//使用defer+recover来捕获和处理异常</span><br><span class="line">//匿名函数</span><br><span class="line">defer func()&#123;</span><br><span class="line">err:=recover()  //recover()是内置函数，可以捕获异常</span><br><span class="line">if err!=nil&#123;   //捕获到错误</span><br><span class="line">fmt.Println(&quot;err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;()</span><br><span class="line"> </span><br><span class="line">num1:=10</span><br><span class="line">num2:=0</span><br><span class="line">res:=num1/num2</span><br><span class="line">fmt.Println(&quot;res=&quot;,res)   //err= runtime error: integer divide by zero</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>main主函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">//错误err的练习</span><br><span class="line">errlab.Testerr()</span><br><span class="line">fmt.Println(&quot;错误后是否会输出@！！&quot;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err= runtime error: integer divide by zero</span><br><span class="line">错误后是否会输出@！！</span><br></pre></td></tr></table></figure><p>从输出结果看出panic()-defer-recover()错误处理并没有影响主程序的代码</p></li></ul><h2 id="err-new-–-gt-自定义错误类型"><a href="#err-new-–-gt-自定义错误类型" class="headerlink" title="err.new()–&gt;自定义错误类型"></a>err.new()–&gt;自定义错误类型</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">func Dingyierr()&#123;</span><br><span class="line">callconfig()</span><br><span class="line">fmt.Println(&quot;callconfig的函数以及下面的代码！&quot;)</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//函数去读取配置文件config。int的信息</span><br><span class="line">//如果文件名不正确就是返回错误</span><br><span class="line">func readconfig(name string )(err error)&#123;</span><br><span class="line">if name==&quot;config.ini&quot;&#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;else &#123;</span><br><span class="line">return errors.New(&quot;读取文件错误...&quot;)   //自定义错误内容事项</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">//调用上面的函数readconfig（）</span><br><span class="line">func callconfig()&#123;</span><br><span class="line">err:=readconfig(&quot;config2.ini&quot;)</span><br><span class="line">if err!=nil&#123;</span><br><span class="line">//如果读取文件发送错误，就是输出这个错误，并终止程序</span><br><span class="line">panic(err)   //panic后，就是终止了程序继续执行了！！！</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;callconfig继续执行。。。。&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GO语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语单词01</title>
      <link href="/hexoblog.github.io/2022/06/30/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D01/"/>
      <url>/hexoblog.github.io/2022/06/30/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D01/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="01-shortcut"><a href="#01-shortcut" class="headerlink" title="01 shortcut"></a>01 shortcut</h1><p>n.近路;捷径;(做某事的)快捷办法，捷径;<br>(显示在计算机桌面上的)快捷方式(图标)</p><p>例:<br>If I take a <strong>shortcut</strong>, I can walk to school for only five minutes.<br>如果抄近路，我只要步行5分钟就能到学校。</p><hr><h1 id="02-validator"><a href="#02-validator" class="headerlink" title="02 validator"></a>02 validator</h1><p>n.验证控件;验证器;校验器,验证;验证程序</p><p>例:<br>You must use an appropriate <strong>validator</strong> for the attribute type.<br>您必须为属性类型使用一个适当的确认器。</p><hr><h1 id="03-internationalization"><a href="#03-internationalization" class="headerlink" title="03 internationalization"></a>03 internationalization</h1><p>n.国际共管；国际化</p><p>例：He has welcomed Luxembourg to take an active part in the <strong>internationalization</strong> process of the Chinese currency.<br>他欢迎卢森堡积极参与中国货币国际化进程。</p><hr><h1 id="04-merge"><a href="#04-merge" class="headerlink" title="04 merge"></a>04 merge</h1><p>v.合并;融入;(使)结合;并入;相融;渐渐消失在某物中</p><p>例：<br>The hills <strong>merged</strong> into the dark sky behind them.<br>山峦渐渐隐入背后漆黑的夜空之中</p><hr><h1 id="05-reference-s"><a href="#05-reference-s" class="headerlink" title="05 reference(s)"></a>05 reference(s)</h1><p>n.参考;说到(或写到)的事;提到;谈及;涉及;查询;查阅;(帮助或意见的)征求，征询;标记，标识，编号;推荐信;推荐人;参考书目<br>vt.查阅;参考;给(书等)附参考资料</p><p>例(n)：<br>The book is full of <strong>references</strong> to growing up in India.<br>这本书谈到许多在印度怎样长大成人的事。</p><p>例(vt):<br>Each chapter is <strong>referenced</strong>, citing literature up to 2004.<br>每一章都附有参考书目，引用文献近至2004年</p><hr><h1 id="06-closure"><a href="#06-closure" class="headerlink" title="06 closure"></a>06 closure</h1><p>n.(永久的)停业，关闭;倒闭;(路或桥的)暂时封闭;(因困境结束或事情得到妥善处理等的)宽慰;如释重负</p><p>例：<br>The village school may face eventual <strong>closure</strong>.<br>这所乡村学校可能最终会面临关闭。</p><hr><h1 id="07-blow"><a href="#07-blow" class="headerlink" title="07 blow"></a>07 blow</h1><p>v.吹;刮;;吹奏（哨子、乐器等）;擤（鼻子）;（向某人）送飞吻;吹出（某物）;（使保险丝）熔化，烧断;炸开;泄露;（在某事物上）花大钱，挥霍;浪费（机会）;突然离开（某地）<br>n.(用手、武器等的)猛击;打击;挫折;吹</p><p>例(v)：<br>Fasten the gates securely so that they do not <strong>blow</strong> open.<br>把大门闩好以免被风吹开。</p><p>例(n)：<br>The decision is a hammer <strong>blow</strong> for the steel industry.<br>这一决定对于钢铁业是一个沉重的打击。</p><hr><h1 id="08-spawn"><a href="#08-spawn" class="headerlink" title="08 spawn"></a>08 spawn</h1><p>v.(鱼、蛙等)产卵</p><p>例:<br>These fish will lay <strong>spawn</strong> in about one month from now.<br>这些鱼大约一个月内会产卵。</p><h1 id="09-syntax"><a href="#09-syntax" class="headerlink" title="09 syntax"></a>09 syntax</h1><p>n.句法;句法规则;语构</p><p>例:<br><strong>Syntax</strong> is all the moeny collected at the church from sinners.<br>句法是教会向罪人收取的赎罪金。</p><h1 id="10-sinner-s"><a href="#10-sinner-s" class="headerlink" title="10 sinner(s)"></a>10 sinner(s)</h1><p> n.罪人</p><p>例:<br>God welcomes the <strong>sinner</strong> who repents.<br>上帝欢迎悔过的罪人。</p><h1 id="11-repent"><a href="#11-repent" class="headerlink" title="11 repent"></a>11 repent</h1><p>v.后悔;悔过;忏悔</p><p>例(v):<br>He came to <strong>repent</strong> his hasty decision.<br>他开始后悔自己的草率决定。</p><h1 id="12-hasty"><a href="#12-hasty" class="headerlink" title="12 hasty"></a>12 hasty</h1><p>adj.匆忙的;仓促而就的;草率的;仓促行事;草率作出决定;考虑不周密</p><p>例:<br>Let’s not make any <strong>hasty</strong> decisions.<br>我们不要匆忙作决定</p><h1 id="13-Benchmarks"><a href="#13-Benchmarks" class="headerlink" title="13 Benchmarks"></a>13 Benchmarks</h1><p>n.行业基准;标杆;基准;基准测试;标竿</p><p>例:<br>The truck industry is a <strong>benchmark</strong> for the economy.<br>卡车业是衡量经济的一个基准</p><h1 id="14-complementary"><a href="#14-complementary" class="headerlink" title="14 complementary"></a>14 complementary</h1><p>adj.互补;互补性;互补的;补充;补充的</p><p>例:<br>To improve the quality of life through work, two <strong>complementary</strong> strategies are necessary<br>想通过工作提高生活质量，需要两个相辅相成的策略</p><h1 id="15-License"><a href="#15-License" class="headerlink" title="15 License"></a>15 License</h1><p>n.许可证;执照;特许<br>vt.许可;批准</p><p>例(n):<br>The government revoked her husband’s <strong>license</strong> to operate migrant labor crews.<br>政府撤销了她丈夫管理外来打工人群的许可证</p><p>例(vt):<br>The new drug has not yet been <strong>licensed</strong> in the US.<br>这种新药尚未在美国获得许可</p><h1 id="16-revoke"><a href="#16-revoke" class="headerlink" title="16 revoke"></a>16 revoke</h1><p>vt.撤销;取消;废除;使无效</p><p>例(vt):<br>I will revoke the challenge.<br>我要撤销这次挑战</p><h1 id="17-domain"><a href="#17-domain" class="headerlink" title="17 domain"></a>17 domain</h1><p>n.(知识、活动的)领域，范围，范畴;(尤指旧时个人、国家等所拥有或统治的)领土，领地，势力范围;域;定义域;区域</p><p>例:<br>The information has been placed in the public <strong>domain</strong>.<br>这资料不受版权保护。</p><h1 id="18-bearer"><a href="#18-bearer" class="headerlink" title="18 bearer"></a>18 bearer</h1><p>n.持票人;持有者;(尤指在礼仪中)持…者;传达消息者;送信人;正式持有人;传授者，传播者</p><p>例:</p><p>The <strong>bearer</strong> need only present proper identification.<br>持票人只需现时有效证明。</p><h1 id="19-stdlib"><a href="#19-stdlib" class="headerlink" title="19 stdlib"></a>19 stdlib</h1><p>标准库</p><p>例:<br>On the other hand, sometimes you do need full threads ( and sometimes the Ruby <strong>stdlib</strong> forces them on you)<br>然而有时你还是需要用完全线程（有时Ruby标准库会迫使你使用它）</p><h1 id="20-manually"><a href="#20-manually" class="headerlink" title="20 manually"></a>20 manually</h1><p>adv.用手地；手动地；人工地</p><p>例:<br>we have to <strong>manually</strong> tap into the central server.<br>就必须手动切入中央服务器</p><h1 id="21-tap"><a href="#21-tap" class="headerlink" title="21 tap"></a>21 tap</h1><p>n.水龙头;龙头;旋塞;轻击;轻拍;轻敲;轻扣;电话窃听;轻拍音<br>v.轻敲;轻拍;轻叩;(用…)轻轻叩击;利用，开发，发掘(已有的资源、知识等);（在电话上）安装窃听器，搭线窃听;在（树）上切口（导出液体）</p><p>例(n):<br>Don’t leave the tap running.<br>别把水龙头开着白白流水。</p><p>例(v):<br>We need to tap the expertise of the people we already have.<br>我们需要利用我们现有人员的专业知识</p><h1 id="22-detect"><a href="#22-detect" class="headerlink" title="22 detect"></a>22 detect</h1><p>vt.发现;查明;侦察出</p><p>And you know, we couldn’t detect any brain activity.<br>你知道，我们没有发现任何大脑活动</p><h1 id="23-infer"><a href="#23-infer" class="headerlink" title="23 infer"></a>23 infer</h1><p>v.推断;推论;推理;间接地提出;暗示;意指</p><p>例:<br>Men observe and infer in all sorts of ways.<br>人们通过各个途径进行观察和推断</p><h1 id="24-explicit"><a href="#24-explicit" class="headerlink" title="24 explicit"></a>24 explicit</h1><p>adj.明确的;清楚明白的;易于理解的;(说话)清晰的;直言的;坦率的;不隐晦的;不含糊的</p><p>例:<br>The reasons for the decision should be made explicit.<br>应该直截了当给出决定的理由。</p><h1 id="25-correlation"><a href="#25-correlation" class="headerlink" title="25 correlation"></a>25 correlation</h1><p>n.相关性;相关;关联;相互关系</p><p>例:<br>There is a direct correlation between exposure to sun and skin cancer.<br>皮肤暴露在太阳下与皮肤癌直接相关</p><h1 id="26-parameter"><a href="#26-parameter" class="headerlink" title="26 parameter"></a>26 parameter</h1><p>n.参数;决定因素;规范;范围</p><p>例:<br>It is the <strong>parameter</strong> of distribution.<br>这就是分布参数。</p><h1 id="27-volatile"><a href="#27-volatile" class="headerlink" title="27 volatile"></a>27 volatile</h1><p>adj.不稳定的;易挥发的;易变的;无定性的;无常性的;可能急剧波动的;易恶化的;易发散的</p><p>例:<br>There have been riots before and the situation is volatile.<br>以前曾发生过暴乱，现在局势不太稳定</p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ·英语单词 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区块链简介</title>
      <link href="/hexoblog.github.io/2022/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B/"/>
      <url>/hexoblog.github.io/2022/06/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="区块链产生"><a href="#区块链产生" class="headerlink" title="区块链产生"></a>区块链产生</h1><h2 id="区块链的诞生"><a href="#区块链的诞生" class="headerlink" title="区块链的诞生"></a>区块链的诞生</h2><p>诞生：2009年1月，比特币问世，基于区块链结构的分布式账本技术大量出现</p><h3 id="区块链的本质：融合了现代密码学和分布式网络技术等重要成果"><a href="#区块链的本质：融合了现代密码学和分布式网络技术等重要成果" class="headerlink" title="区块链的本质：融合了现代密码学和分布式网络技术等重要成果"></a>区块链的本质：融合了现代密码学和分布式网络技术等重要成果</h3><h4 id="数据存储：区块：一种交易记录的数据结构"><a href="#数据存储：区块：一种交易记录的数据结构" class="headerlink" title="数据存储：区块：一种交易记录的数据结构"></a>数据存储：区块：一种交易记录的数据结构</h4><h5 id="1-区块主体：负责记录前一段时间内所有的交易记录"><a href="#1-区块主体：负责记录前一段时间内所有的交易记录" class="headerlink" title="1.区块主体：负责记录前一段时间内所有的交易记录"></a>1.区块主体：负责记录前一段时间内所有的交易记录</h5><h5 id="2-区块头：记录前期交易的数据指纹和本区块的数据指纹"><a href="#2-区块头：记录前期交易的数据指纹和本区块的数据指纹" class="headerlink" title="2.区块头：记录前期交易的数据指纹和本区块的数据指纹"></a>2.区块头：记录前期交易的数据指纹和本区块的数据指纹</h5><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><h5 id="1-去中心化：任意节点间权利义务均等"><a href="#1-去中心化：任意节点间权利义务均等" class="headerlink" title="1.去中心化：任意节点间权利义务均等"></a>1.去中心化：任意节点间权利义务均等</h5><h5 id="2-集体维护：账本由所有节点共同维护"><a href="#2-集体维护：账本由所有节点共同维护" class="headerlink" title="2.集体维护：账本由所有节点共同维护"></a>2.集体维护：账本由所有节点共同维护</h5><h5 id="3-高度透明：账本和规则所以人可审查"><a href="#3-高度透明：账本和规则所以人可审查" class="headerlink" title="3.高度透明：账本和规则所以人可审查"></a>3.高度透明：账本和规则所以人可审查</h5><h5 id="4-匿名：区块链解决了信任问题，没必要了解对方"><a href="#4-匿名：区块链解决了信任问题，没必要了解对方" class="headerlink" title="4.匿名：区块链解决了信任问题，没必要了解对方"></a>4.匿名：区块链解决了信任问题，没必要了解对方</h5><h4 id="账本科技的重要性"><a href="#账本科技的重要性" class="headerlink" title="账本科技的重要性"></a>账本科技的重要性</h4><h5 id="保障社会文明的最核心的基石"><a href="#保障社会文明的最核心的基石" class="headerlink" title="保障社会文明的最核心的基石"></a>保障社会文明的最核心的基石</h5><h5 id="人类发明的重要历程"><a href="#人类发明的重要历程" class="headerlink" title="人类发明的重要历程"></a>人类发明的重要历程</h5><h4 id="账本科技的演化"><a href="#账本科技的演化" class="headerlink" title="账本科技的演化"></a>账本科技的演化</h4><h5 id="阶段一：简单账本"><a href="#阶段一：简单账本" class="headerlink" title="阶段一：简单账本"></a>阶段一：简单账本</h5><h5 id="特点：1-简单的原始记账2-利用单条记录进行账目记录，使用物理媒介"><a href="#特点：1-简单的原始记账2-利用单条记录进行账目记录，使用物理媒介" class="headerlink" title="特点：1.简单的原始记账2.利用单条记录进行账目记录，使用物理媒介"></a>特点：1.简单的原始记账2.利用单条记录进行账目记录，使用物理媒介</h5><h5 id="缺点：1-账户记录不完整2-不能反应经济业务来龙去脉3-不便于检查账户记录完整4-容易错误，容易篡改"><a href="#缺点：1-账户记录不完整2-不能反应经济业务来龙去脉3-不便于检查账户记录完整4-容易错误，容易篡改" class="headerlink" title="缺点：1.账户记录不完整2.不能反应经济业务来龙去脉3.不便于检查账户记录完整4.容易错误，容易篡改"></a>缺点：1.账户记录不完整2.不能反应经济业务来龙去脉3.不便于检查账户记录完整4.容易错误，容易篡改</h5><h5 id="阶段二：复式账本"><a href="#阶段二：复式账本" class="headerlink" title="阶段二：复式账本"></a>阶段二：复式账本</h5><h6 id="交易本质的是将某种价值从来源方转移到目标方"><a href="#交易本质的是将某种价值从来源方转移到目标方" class="headerlink" title="交易本质的是将某种价值从来源方转移到目标方"></a>交易本质的是将某种价值从来源方转移到目标方</h6><h5 id="特点：1-容易对交易来龙去脉进行追踪2-可以验证账目是否正确"><a href="#特点：1-容易对交易来龙去脉进行追踪2-可以验证账目是否正确" class="headerlink" title="特点：1.容易对交易来龙去脉进行追踪2.可以验证账目是否正确"></a>特点：1.容易对交易来龙去脉进行追踪2.可以验证账目是否正确</h5><h5 id="缺点：对账困难、发现问题不及时、存在联合舞弊的可能"><a href="#缺点：对账困难、发现问题不及时、存在联合舞弊的可能" class="headerlink" title="缺点：对账困难、发现问题不及时、存在联合舞弊的可能"></a>缺点：对账困难、发现问题不及时、存在联合舞弊的可能</h5><h5 id="阶段三：数字化账本"><a href="#阶段三：数字化账本" class="headerlink" title="阶段三：数字化账本"></a>阶段三：数字化账本</h5><h5 id="特点：1-记账方法本身较于复式记账没有太多创新2-账本的规模、处理的速度、账本的复杂度有了提升"><a href="#特点：1-记账方法本身较于复式记账没有太多创新2-账本的规模、处理的速度、账本的复杂度有了提升" class="headerlink" title="特点：1.记账方法本身较于复式记账没有太多创新2.账本的规模、处理的速度、账本的复杂度有了提升"></a>特点：1.记账方法本身较于复式记账没有太多创新2.账本的规模、处理的速度、账本的复杂度有了提升</h5><h5 id="缺点（准确来说是中心化账本存在的问题）：1-十分依赖中心化机构的可信度2-信息存储安全，如支付宝数据库崩掉，信息丢失咋办3-中心化机构掌握客户全部的权力，特别是数据权力，而中心机构掌握的资源越多，垄断机构获得的利益就越多"><a href="#缺点（准确来说是中心化账本存在的问题）：1-十分依赖中心化机构的可信度2-信息存储安全，如支付宝数据库崩掉，信息丢失咋办3-中心化机构掌握客户全部的权力，特别是数据权力，而中心机构掌握的资源越多，垄断机构获得的利益就越多" class="headerlink" title="缺点（准确来说是中心化账本存在的问题）：1.十分依赖中心化机构的可信度2.信息存储安全，如支付宝数据库崩掉，信息丢失咋办3.中心化机构掌握客户全部的权力，特别是数据权力，而中心机构掌握的资源越多，垄断机构获得的利益就越多"></a>缺点（准确来说是中心化账本存在的问题）：1.十分依赖中心化机构的可信度2.信息存储安全，如支付宝数据库崩掉，信息丢失咋办3.中心化机构掌握客户全部的权力，特别是数据权力，而中心机构掌握的资源越多，垄断机构获得的利益就越多</h5><h5 id="阶段四：分布式账本"><a href="#阶段四：分布式账本" class="headerlink" title="阶段四：分布式账本"></a>阶段四：分布式账本</h5><h5 id="定义：1．-分布式账本是一种可在所有成员之间共享、复制和同步的账本。"><a href="#定义：1．-分布式账本是一种可在所有成员之间共享、复制和同步的账本。" class="headerlink" title="定义：1． 分布式账本是一种可在所有成员之间共享、复制和同步的账本。"></a>定义：1． 分布式账本是一种可在所有成员之间共享、复制和同步的账本。</h5><h5 id="特点：1-第三方记账，区分于复式记账各自记账2-共享记账3-全信息账本，不仅记录资金流，也记录了信息流"><a href="#特点：1-第三方记账，区分于复式记账各自记账2-共享记账3-全信息账本，不仅记录资金流，也记录了信息流" class="headerlink" title="特点：1.第三方记账，区分于复式记账各自记账2.共享记账3.全信息账本，不仅记录资金流，也记录了信息流"></a>特点：1.第三方记账，区分于复式记账各自记账2.共享记账3.全信息账本，不仅记录资金流，也记录了信息流</h5><h1 id="区块链基本概念"><a href="#区块链基本概念" class="headerlink" title="区块链基本概念"></a>区块链基本概念</h1><h3 id="区块链定义"><a href="#区块链定义" class="headerlink" title="区块链定义"></a>区块链定义</h3><h4 id="区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的分布式账本"><a href="#区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的分布式账本" class="headerlink" title="区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的分布式账本"></a>区块链是一种按照时间顺序将数据区块以顺序相连的方式组合成的一种链式数据结构，并以密码学方式保证的不可篡改和不可伪造的分布式账本</h4><h4 id="不可篡改"><a href="#不可篡改" class="headerlink" title="不可篡改"></a>不可篡改</h4><h5 id="数据结构：由于区块包含父区块的数据指纹，任何区块的修改都会引起所在区块的数据指纹发生变化，导致后面的其他节点发生变化"><a href="#数据结构：由于区块包含父区块的数据指纹，任何区块的修改都会引起所在区块的数据指纹发生变化，导致后面的其他节点发生变化" class="headerlink" title="数据结构：由于区块包含父区块的数据指纹，任何区块的修改都会引起所在区块的数据指纹发生变化，导致后面的其他节点发生变化"></a>数据结构：由于区块包含父区块的数据指纹，任何区块的修改都会引起所在区块的数据指纹发生变化，导致后面的其他节点发生变化</h5><h5 id="数据存储：区块数据分布存在多个节点中，系统自定认为最多的账本是真账本，任何人想要篡改数据就需要修改51-以上节点数据"><a href="#数据存储：区块数据分布存在多个节点中，系统自定认为最多的账本是真账本，任何人想要篡改数据就需要修改51-以上节点数据" class="headerlink" title="数据存储：区块数据分布存在多个节点中，系统自定认为最多的账本是真账本，任何人想要篡改数据就需要修改51%以上节点数据"></a>数据存储：区块数据分布存在多个节点中，系统自定认为最多的账本是真账本，任何人想要篡改数据就需要修改51%以上节点数据</h5><h5 id="不可伪造：所有上链信息都可追溯到其诞生的那个区块，几乎包含其所有信息"><a href="#不可伪造：所有上链信息都可追溯到其诞生的那个区块，几乎包含其所有信息" class="headerlink" title="不可伪造：所有上链信息都可追溯到其诞生的那个区块，几乎包含其所有信息"></a>不可伪造：所有上链信息都可追溯到其诞生的那个区块，几乎包含其所有信息</h5><h3 id="区块链交易流程"><a href="#区块链交易流程" class="headerlink" title="区块链交易流程"></a>区块链交易流程</h3><h5 id="转账发送方–-gt-交易传播（p2p网络）–-gt-参与节点记录–-gt-记账共识–-gt-校验–-gt-区块添加–-gt-接收方收到转账"><a href="#转账发送方–-gt-交易传播（p2p网络）–-gt-参与节点记录–-gt-记账共识–-gt-校验–-gt-区块添加–-gt-接收方收到转账" class="headerlink" title="转账发送方–&gt;交易传播（p2p网络）–&gt;参与节点记录–&gt;记账共识–&gt;校验–&gt;区块添加–&gt;接收方收到转账"></a>转账发送方–&gt;交易传播（p2p网络）–&gt;参与节点记录–&gt;记账共识–&gt;校验–&gt;区块添加–&gt;接收方收到转账</h5><h2 id="区块链主要特点"><a href="#区块链主要特点" class="headerlink" title="#区块链主要特点"></a>#区块链主要特点</h2><h3 id="01-去中心化"><a href="#01-去中心化" class="headerlink" title="01.去中心化"></a>01.去中心化</h3><h4 id="a-不依赖任何第三方中介机构做背书，所有参与者自己给自己做背书"><a href="#a-不依赖任何第三方中介机构做背书，所有参与者自己给自己做背书" class="headerlink" title="a.不依赖任何第三方中介机构做背书，所有参与者自己给自己做背书"></a>a.不依赖任何第三方中介机构做背书，所有参与者自己给自己做背书</h4><h4 id="b-任意节点权力义务均等"><a href="#b-任意节点权力义务均等" class="headerlink" title="b.任意节点权力义务均等"></a>b.任意节点权力义务均等</h4><h4 id="c-系统中的数据分布式存储，数据块由具有维护功能的节点共同维护"><a href="#c-系统中的数据分布式存储，数据块由具有维护功能的节点共同维护" class="headerlink" title="c.系统中的数据分布式存储，数据块由具有维护功能的节点共同维护"></a>c.系统中的数据分布式存储，数据块由具有维护功能的节点共同维护</h4><h3 id="02-安全且不可篡改"><a href="#02-安全且不可篡改" class="headerlink" title="02.安全且不可篡改"></a>02.安全且不可篡改</h3><h4 id="a-篡改必须攻破51-的参与者信息"><a href="#a-篡改必须攻破51-的参与者信息" class="headerlink" title="a.篡改必须攻破51%的参与者信息"></a>a.篡改必须攻破51%的参与者信息</h4><h4 id="b-区块链账本中的交易数据只能通过被认可的新交易来”修正”-修正的过程就留下痕迹"><a href="#b-区块链账本中的交易数据只能通过被认可的新交易来”修正”-修正的过程就留下痕迹" class="headerlink" title="b.区块链账本中的交易数据只能通过被认可的新交易来”修正”,修正的过程就留下痕迹"></a>b.区块链账本中的交易数据只能通过被认可的新交易来”修正”,修正的过程就留下痕迹</h4><h3 id="03-公开"><a href="#03-公开" class="headerlink" title="03.公开"></a>03.公开</h3><h4 id="a-记账结果对所有参与者公开"><a href="#a-记账结果对所有参与者公开" class="headerlink" title="a.记账结果对所有参与者公开"></a>a.记账结果对所有参与者公开</h4><h4 id="b-任何人能通过公开的接口进行查询-整个系统信息高度透明"><a href="#b-任何人能通过公开的接口进行查询-整个系统信息高度透明" class="headerlink" title="b.任何人能通过公开的接口进行查询,整个系统信息高度透明"></a>b.任何人能通过公开的接口进行查询,整个系统信息高度透明</h4><h3 id="04-匿名"><a href="#04-匿名" class="headerlink" title="04.匿名"></a>04.匿名</h3><h4 id="a-记账人的实际对应人匿名"><a href="#a-记账人的实际对应人匿名" class="headerlink" title="a.记账人的实际对应人匿名"></a>a.记账人的实际对应人匿名</h4><h4 id="b-算法是实现的地址寻址-而不是个人身份"><a href="#b-算法是实现的地址寻址-而不是个人身份" class="headerlink" title="b.算法是实现的地址寻址,而不是个人身份"></a>b.算法是实现的地址寻址,而不是个人身份</h4><h4 id="c-节点数据交换遵循固定算法-其数据交互无须信任的"><a href="#c-节点数据交换遵循固定算法-其数据交互无须信任的" class="headerlink" title="c.节点数据交换遵循固定算法,其数据交互无须信任的"></a>c.节点数据交换遵循固定算法,其数据交互无须信任的</h4><h3 id="05-可追溯"><a href="#05-可追溯" class="headerlink" title="05.可追溯"></a>05.可追溯</h3><h4 id="a-区块链固化了交易历史-保证对历史的追溯查询"><a href="#a-区块链固化了交易历史-保证对历史的追溯查询" class="headerlink" title="a.区块链固化了交易历史,保证对历史的追溯查询"></a>a.区块链固化了交易历史,保证对历史的追溯查询</h4><h4 id="b-能够防止一系列信息伪造-能够知道上链信息来源-产生时间"><a href="#b-能够防止一系列信息伪造-能够知道上链信息来源-产生时间" class="headerlink" title="b.能够防止一系列信息伪造,能够知道上链信息来源,产生时间"></a>b.能够防止一系列信息伪造,能够知道上链信息来源,产生时间</h4><h2 id="区块链演进"><a href="#区块链演进" class="headerlink" title="#区块链演进"></a>#区块链演进</h2><h3 id="三次阶段："><a href="#三次阶段：" class="headerlink" title="三次阶段："></a>三次阶段：</h3><h3 id="区块链1-0"><a href="#区块链1-0" class="headerlink" title="区块链1.0"></a>区块链1.0</h3><h5 id="可编程货币-比特币-数字货币-基于程序算法"><a href="#可编程货币-比特币-数字货币-基于程序算法" class="headerlink" title="可编程货币:比特币,数字货币,基于程序算法"></a>可编程货币:比特币,数字货币,基于程序算法</h5><h5 id="瓶颈-挖矿高耗能"><a href="#瓶颈-挖矿高耗能" class="headerlink" title="瓶颈:挖矿高耗能"></a>瓶颈:挖矿高耗能</h5><h3 id="区块链2-0"><a href="#区块链2-0" class="headerlink" title="区块链2.0"></a>区块链2.0</h3><h5 id="可编程金融-以太坊-数字货币-智能合约"><a href="#可编程金融-以太坊-数字货币-智能合约" class="headerlink" title="可编程金融:以太坊,数字货币,智能合约"></a>可编程金融:以太坊,数字货币,智能合约</h5><h5 id="瓶颈-拥堵手续费高"><a href="#瓶颈-拥堵手续费高" class="headerlink" title="瓶颈:拥堵手续费高"></a>瓶颈:拥堵手续费高</h5><h3 id="区块链3-0"><a href="#区块链3-0" class="headerlink" title="区块链3.0"></a>区块链3.0</h3><h5 id="可编程社会-数字票证-基于事物资产映射"><a href="#可编程社会-数字票证-基于事物资产映射" class="headerlink" title="可编程社会:数字票证,基于事物资产映射"></a>可编程社会:数字票证,基于事物资产映射</h5><h5 id="解决1-0-2-0瓶颈并行绿色-高兼容"><a href="#解决1-0-2-0瓶颈并行绿色-高兼容" class="headerlink" title="解决1.0 2.0瓶颈并行绿色,高兼容"></a>解决1.0 2.0瓶颈并行绿色,高兼容</h5><h3 id="三次热潮"><a href="#三次热潮" class="headerlink" title="三次热潮"></a>三次热潮</h3><h3 id="第一次热潮-以比特币为核心的加密货币"><a href="#第一次热潮-以比特币为核心的加密货币" class="headerlink" title="第一次热潮:以比特币为核心的加密货币"></a>第一次热潮:以比特币为核心的加密货币</h3><h3 id="第二次热潮-以区块链为基础的分布式账本"><a href="#第二次热潮-以区块链为基础的分布式账本" class="headerlink" title="第二次热潮:以区块链为基础的分布式账本"></a>第二次热潮:以区块链为基础的分布式账本</h3><h3 id="第三次热潮-ICO-资本关注-部分项目落地"><a href="#第三次热潮-ICO-资本关注-部分项目落地" class="headerlink" title="第三次热潮:ICO,资本关注,部分项目落地"></a>第三次热潮:ICO,资本关注,部分项目落地</h3><h2 id="区块链的主要类型及应用"><a href="#区块链的主要类型及应用" class="headerlink" title="#区块链的主要类型及应用"></a>#区块链的主要类型及应用</h2><h3 id="许可链"><a href="#许可链" class="headerlink" title="许可链"></a>许可链</h3><h4 id="联盟链"><a href="#联盟链" class="headerlink" title="联盟链"></a>联盟链</h4><h5 id="a-特点："><a href="#a-特点：" class="headerlink" title="a.特点："></a>a.特点：</h5><h5 id="仅联盟成员参与-读写由联盟规则制定-交易速度较于公有链大大提升"><a href="#仅联盟成员参与-读写由联盟规则制定-交易速度较于公有链大大提升" class="headerlink" title="仅联盟成员参与;读写由联盟规则制定;交易速度较于公有链大大提升"></a>仅联盟成员参与;读写由联盟规则制定;交易速度较于公有链大大提升</h5><h5 id="b-应用场景"><a href="#b-应用场景" class="headerlink" title="b.应用场景"></a>b.应用场景</h5><h5 id="01-使用在多个成员角色的环境中，可以解决结算问题，降低两地结算的成本和时间，适合于机构间的交易、结算等B2B场景，因此金融行业应用最广泛"><a href="#01-使用在多个成员角色的环境中，可以解决结算问题，降低两地结算的成本和时间，适合于机构间的交易、结算等B2B场景，因此金融行业应用最广泛" class="headerlink" title="01.使用在多个成员角色的环境中，可以解决结算问题，降低两地结算的成本和时间，适合于机构间的交易、结算等B2B场景，因此金融行业应用最广泛"></a>01.使用在多个成员角色的环境中，可以解决结算问题，降低两地结算的成本和时间，适合于机构间的交易、结算等B2B场景，因此金融行业应用最广泛</h5><h5 id="02-比如银行之间的支付结算、企业之间的物流等"><a href="#02-比如银行之间的支付结算、企业之间的物流等" class="headerlink" title="02.比如银行之间的支付结算、企业之间的物流等"></a>02.比如银行之间的支付结算、企业之间的物流等</h5><h4 id="私有链"><a href="#私有链" class="headerlink" title="私有链"></a>私有链</h4><h5 id="a-特点-对外不开放-仅仅在内部使用的系统-信息不公开"><a href="#a-特点-对外不开放-仅仅在内部使用的系统-信息不公开" class="headerlink" title="a.特点:对外不开放,仅仅在内部使用的系统,信息不公开"></a>a.特点:对外不开放,仅仅在内部使用的系统,信息不公开</h5><h5 id="b-应用场景-1"><a href="#b-应用场景-1" class="headerlink" title="b.应用场景"></a>b.应用场景</h5><h5 id="01-限于企业、机构或者单独个体使用，彼此之间需要透明，但没必要对外公众透明"><a href="#01-限于企业、机构或者单独个体使用，彼此之间需要透明，但没必要对外公众透明" class="headerlink" title="01.限于企业、机构或者单独个体使用，彼此之间需要透明，但没必要对外公众透明"></a>01.限于企业、机构或者单独个体使用，彼此之间需要透明，但没必要对外公众透明</h5><h5 id="02-比如企业的票据管理、账务审计、供应链管理等，或者一些政务管理系统等"><a href="#02-比如企业的票据管理、账务审计、供应链管理等，或者一些政务管理系统等" class="headerlink" title="02.比如企业的票据管理、账务审计、供应链管理等，或者一些政务管理系统等"></a>02.比如企业的票据管理、账务审计、供应链管理等，或者一些政务管理系统等</h5><h3 id="非许可链-公有链"><a href="#非许可链-公有链" class="headerlink" title="非许可链(公有链)"></a>非许可链(公有链)</h3><h4 id="a-特点-任何人可参与使用和维护-参与者多为匿名-信息完全公开"><a href="#a-特点-任何人可参与使用和维护-参与者多为匿名-信息完全公开" class="headerlink" title="a.特点:任何人可参与使用和维护,参与者多为匿名,信息完全公开"></a>a.特点:任何人可参与使用和维护,参与者多为匿名,信息完全公开</h4><h4 id="b-应用场景-2"><a href="#b-应用场景-2" class="headerlink" title="b.应用场景"></a>b.应用场景</h4><h5 id="01-凡是需要公众参与，及最大限度保证数据公开透明的系统"><a href="#01-凡是需要公众参与，及最大限度保证数据公开透明的系统" class="headerlink" title="01.凡是需要公众参与，及最大限度保证数据公开透明的系统"></a>01.凡是需要公众参与，及最大限度保证数据公开透明的系统</h5><h5 id="02-比如数字货币系统、众筹系统、金融交易系统等"><a href="#02-比如数字货币系统、众筹系统、金融交易系统等" class="headerlink" title="02.比如数字货币系统、众筹系统、金融交易系统等"></a>02.比如数字货币系统、众筹系统、金融交易系统等</h5><h3 id="不可能三角-1-去中心化-公有链-2-安全-私有链-3-高效-联盟链"><a href="#不可能三角-1-去中心化-公有链-2-安全-私有链-3-高效-联盟链" class="headerlink" title="不可能三角:1.去中心化(公有链) 2.安全 (私有链)3.高效(联盟链)"></a>不可能三角:1.去中心化(公有链) 2.安全 (私有链)3.高效(联盟链)</h3><h2 id="区块链现实意义"><a href="#区块链现实意义" class="headerlink" title="#区块链现实意义"></a>#区块链现实意义</h2><h3 id="核心价值"><a href="#核心价值" class="headerlink" title="核心价值"></a>核心价值</h3><h5 id="区块链解决了信息可信问题"><a href="#区块链解决了信息可信问题" class="headerlink" title="区块链解决了信息可信问题"></a>区块链解决了信息可信问题</h5><h5 id="区块链解决了价值传递问题"><a href="#区块链解决了价值传递问题" class="headerlink" title="区块链解决了价值传递问题"></a>区块链解决了价值传递问题</h5><h3 id="业务特性"><a href="#业务特性" class="headerlink" title="业务特性"></a>业务特性</h3><h5 id="可信任性"><a href="#可信任性" class="headerlink" title="可信任性"></a>可信任性</h5><h5 id="降低成本"><a href="#降低成本" class="headerlink" title="降低成本"></a>降低成本</h5><h5 id="增强安全"><a href="#增强安全" class="headerlink" title="增强安全"></a>增强安全</h5><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h6 id="所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益"><a href="#所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益" class="headerlink" title="所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益"></a>所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益</h6><h3 id="现实意义"><a href="#现实意义" class="headerlink" title="现实意义"></a>现实意义</h3><h5 id="人类社会形成的基础"><a href="#人类社会形成的基础" class="headerlink" title="人类社会形成的基础"></a>人类社会形成的基础</h5><h5 id="现代信息世界的组成"><a href="#现代信息世界的组成" class="headerlink" title="现代信息世界的组成"></a>现代信息世界的组成</h5>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ·区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比特币简介</title>
      <link href="/hexoblog.github.io/2022/06/18/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E4%BB%8B/"/>
      <url>/hexoblog.github.io/2022/06/18/%E6%AF%94%E7%89%B9%E5%B8%81%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="比特币简介"><a href="#比特币简介" class="headerlink" title="比特币简介"></a>比特币简介</h1><h2 id="比特币的诞生："><a href="#比特币的诞生：" class="headerlink" title="比特币的诞生："></a>比特币的诞生：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| 1977年  |货币非国有化主张</span><br><span class="line">| 1982年  |拜占庭问题</span><br><span class="line">| 1990年  |Paxos算法</span><br><span class="line">| 1991年  |时间戳确保数位文件安全协议</span><br><span class="line">| 1997年  |那哈希现金系统</span><br><span class="line">| 1998年  |Pow机制</span><br><span class="line">| 2008年前|RPow（可重复使用的工作量证明）</span><br><span class="line">| 2008年  |白皮书《比特币：一种点对点电子现金系统》</span><br></pre></td></tr></table></figure><p> 比特币白皮书：<a href="https://github.com/GammaGao/bitcoinwhitepaper">比特币₿白皮书 BTCpapers.com《比特币：一种点对点的电子现金系统</a><br>    本质：一套管钱的账本</p><h1 id="比特币系统的工作原理"><a href="#比特币系统的工作原理" class="headerlink" title="比特币系统的工作原理"></a>比特币系统的工作原理</h1><h2 id="比特币面临的挑战？"><a href="#比特币面临的挑战？" class="headerlink" title="比特币面临的挑战？"></a>比特币面临的挑战？</h2><ul><li>为什么要动用自己的计算机资源来存储这些信息呢??</li><li>以谁的记录为准？？</li><li>比特币如何做到支付功能??</li><li>比特币如何防伪??</li><li>比特币如何防篡改??</li><li>比特币如何防双重支付??</li></ul><hr><h2 id="比特币交易流程："><a href="#比特币交易流程：" class="headerlink" title="比特币交易流程："></a>比特币交易流程：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Alice打开他的钱包--&gt;</span><br><span class="line">Alice扫描Bob的比特币地址--&gt;</span><br><span class="line">Alice填写交易账单--&gt;</span><br><span class="line">Alice提交交易账单给钱包--&gt;</span><br><span class="line">钱包使用Alice的私钥对交易账单对交易账单签名--&gt;</span><br><span class="line">交易被发送到比特币网络上最近的节点--&gt;</span><br><span class="line">矿工将交易打包到下一个要挖掘的区块--&gt;</span><br><span class="line">矿工开始挖矿--&gt;</span><br><span class="line">获取该块记账权的矿工将新区块传播到网络--&gt;</span><br><span class="line">其他节点验证挖矿结果并传播新区块--&gt;</span><br><span class="line">Bob看到了第一个确认--&gt;</span><br><span class="line">(创建每个区块都会出现新的确认)</span><br></pre></td></tr></table></figure><hr><h2 id="比特币钱包"><a href="#比特币钱包" class="headerlink" title="比特币钱包"></a>比特币钱包</h2><ul><li><p>本质：</p><ul><li>比特币钱包是用来存放比特币地址和数字密钥的(地址相当于银行卡卡号;密钥相当于银行卡密码)</li><li>比特币的所有权是通过数字密钥,比特币地址和数字签名确立的</li><li>密钥相当于银行卡密码；地址相当于银行卡卡号</li></ul></li><li><p>分类：</p><ul><li>热钱包:在线钱包</li><li>冷钱包:离线钱包</li></ul></li><li><p>支付相关：</p><ul><li>比特币私钥主要用于用户接收支付，公钥用于别人来验证</li><li>支付比特币时，比特币的当前拥有者需要在交易中提交其签名和公钥</li><li>比特币地址用于接收比特币，私钥用于比特币支付时进行交易签名</li><li>每个输入都是提供比特币的交易和地址；每个输出是接收比特币的地址，以及发送到该地址的比特币数量</li></ul></li></ul><h3 id="比特币地址生成"><a href="#比特币地址生成" class="headerlink" title="比特币地址生成 :"></a>比特币地址生成 :</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">随机函数--&gt;私钥--(椭圆曲线)--&gt;公钥--(系列哈希其他处理)--&gt;比特币地址</span><br></pre></td></tr></table></figure><h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本:"></a>脚本:</h3><ul><li>解锁脚本:由其他人提供,用以解决”障碍”</li><li>锁定脚本:存在于一笔交易输出中,如果要使用输出,锁定脚本时必须被满足的”障碍”</li></ul><h3 id="双花问题"><a href="#双花问题" class="headerlink" title="双花问题"></a>双花问题</h3><ul><li><p>定义:<br> “双花”即双重支付,指的是在数字货币系统中,由于数据的可复制性,使得系统可能存在同一笔数字资产因不当操作被重复使用的情况</p></li><li><p>重要性:<br> “双花”是任何一种数字货币都要解决的问题</p></li><li><p>比特币解决方式:</p><ul><li><p>未花费交易输出(UTXO)</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.定义:UTXO是一个包含交易数据和执行代码的数据结构,可以理解未收到但尚未花费的交易清单</span><br><span class="line">2.普遍性:比特币系统中记录着当前每一笔&quot;UTXO&quot;</span><br><span class="line">3.优点:</span><br><span class="line"> a.不能被分割,只能被消耗,大大减少计算量</span><br><span class="line"> b.配合地址使用,具备天然匿名性,保护了账户安全</span><br><span class="line"> c.由于地址存在,UTXO销毁和产生,都可追溯,很难伪造</span><br></pre></td></tr></table></figure></li><li><p>时间戳</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.定义:从格林威治时间1970年01月01日00时00分00秒起,至现在的总秒数,唯一标识区块数据的写入时刻</span><br><span class="line">2.作用:时间戳是一个能表示一份数据在某个特定时间已经存在的,完整的,可验证的数据,通常是一个字符序列,唯一地标识某一刻的时间</span><br><span class="line">3.普遍性:时间戳保证每个区块按时间顺序连成区块链,时间戳也为区块链上每一笔数据打上时间标记(类似物品上的生产日期)</span><br></pre></td></tr></table></figure></li><li><p>解决双花的两种问题</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.第一笔交易已经入块，第二笔交易还未入块</span><br><span class="line">    a.解决思路：每笔交易都需要先确认对应比特币之前的状态，如果它之前已经被标记为花掉，那么新的交易会被拒绝</span><br><span class="line">2.第一笔交易还未入块，第二笔交易也未入块</span><br><span class="line">    b.解决思路：正常情况下，节点会确认先接收到的那一个交易，另外一个交易会被拒绝；如果被不同节点确认，区块链将会发生分叉，剩余节点会选取最长的链上构建新的区块，当其中一笔交易被6个节点确认后，可以认为这笔交易获得了最终的确认</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="比特币数据结构"><a href="#比特币数据结构" class="headerlink" title="比特币数据结构"></a>比特币数据结构</h1><h2 id="区块链的存储结构"><a href="#区块链的存储结构" class="headerlink" title="区块链的存储结构:"></a>区块链的存储结构:</h2><ul><li>定义：连接了父区块和子区块,每一个区块分为区块头和区块体</li></ul><h2 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h2><ul><li><p>作用:主要用来存储本区块的一些相关属性</p></li><li><p>组成:<br>   本区块哈希值:<br>              定义:H(n),包含父区块与本区块全部交易信息的DNA<br>   系统版本号<br>   父区块哈希值<br>   时间戳:<br>              定义:从格林威治时间1970年01月01日00时00分00秒起,至现在的总秒数,唯一标识区块数据的写入时刻<br><br>   随机值:<br>              定义:挖矿参数H(随机数)&#x3D;hash(版本号+父区块哈希值+默克尔值+时间戳+时间数)<br><br>   默克尔树:<br>              结构:交易的哈希生成唯一的默克尔树<br>              应用：<br>                  a.快速比较大量数据<br>                  b.快速定位修改<br>                  c.快速检索防伪<br>                  d.零知识证明<br><br><br>   挖矿难度:<br>              新难度&#x3D;旧难度*(2016*10min)&#x2F;过去2016个区块生成总时间</p></li></ul><h2 id="区块体"><a href="#区块体" class="headerlink" title="区块体:"></a>区块体:</h2><ul><li>定义：用来存储真实的交易数据记录的存储结构</li></ul><hr><h1 id="比特币交易签名及验证"><a href="#比特币交易签名及验证" class="headerlink" title="比特币交易签名及验证"></a>比特币交易签名及验证</h1><h2 id="比特币验证"><a href="#比特币验证" class="headerlink" title="比特币验证:"></a>比特币验证:</h2><ul><li>账号所有权验证:如何在不泄露密码的前提下,证明自己对某个账户的所有权?</li><li>比特币所有权验证:如何在不泄露密码的前提下,证明自己对要交易的比特币的所有权?</li><li>交易所有权验证:如何在不泄露密码的前提下,证明某个交易的确时你创建的呢?</li><li>解决方法：在去中心化的前提下，每个节点独立进行验证</li></ul><h2 id="交易的构成："><a href="#交易的构成：" class="headerlink" title="交易的构成："></a>交易的构成：</h2><ul><li>Input:计算花费的UTXO来源</li><li>Output：计划生成几个UTXO，分别给谁</li></ul><h2 id="交易的签名"><a href="#交易的签名" class="headerlink" title="交易的签名"></a>交易的签名</h2><ul><li>锁定脚本(scriptPubKey):放置在输出上面的花费条件，指定了今后花费这笔UTXO必须要满足的条件</li><li>解锁脚本(scriptSig)：解锁脚本是一个满足被锁定脚本在一个输出上设定的花费条件的脚本</li><li>签名的输入：<ul><li>代签名的交易数据</li><li>引用的UTXO相关信息：交易ID，序号，锁定脚本</li><li>支付者的公钥：&lt;PriK(B)&gt;</li><li>签名类型</li></ul></li><li>签名的输出：<br> scriptSig（解锁脚本）：签名(sig&gt;)、支付者的公钥(&lt;PubK(B)&gt;)</li></ul><h2 id="交易签名的验证"><a href="#交易签名的验证" class="headerlink" title="交易签名的验证"></a>交易签名的验证</h2><ul><li>交易验证目的:</li><li>签名验证的目的:</li><li>签名验证的方法:</li></ul><hr><h1 id="比特币共识机制"><a href="#比特币共识机制" class="headerlink" title="比特币共识机制"></a>比特币共识机制</h1><h2 id="区块链共识机制"><a href="#区块链共识机制" class="headerlink" title="区块链共识机制:"></a>区块链共识机制:</h2><ul><li>区块链共识算法</li><li>区块链共识规则</li><li>重要性:每个区块链都有自己精心设计好的规则性协议,这些协议通过共识算法来保证它们-可靠得以执行</li></ul><h2 id="比特币共识机制："><a href="#比特币共识机制：" class="headerlink" title="比特币共识机制："></a>比特币共识机制：</h2><ul><li>比特币共识算法:SHA256算法</li><li>比特币共识机制:工作量证明(Pow)</li><li>重要性:每一个节点必须要做一定的工作后才能赢得记账权,即工作量证明</li><li>独立打包–&gt;交易优先级计算:交易优先级&#x3D;交易UTXO的值*UTXO的块龄&#x2F;交易大小(字节)<br>独立验证：挖矿过程这个过程使用的是SHA256哈希函数，挖矿节节点不断重复尝试，直到它找到的随机调整数使得产生的哈希值低于某个特定的目标</li><li>区块链的组装和选择：<ul><li>孤块：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.定义:如果节点收到了一个有效的区块,而在现有的区块链中却未找到它的父区块,那么这个区块被认为是&quot;孤块&quot;</span><br><span class="line">      出现情况:当两个区块在很短时间间隔内被挖出来,节点有可能会以相反的顺序接收到它们,这个时候孤块现象就会出现</span><br><span class="line"></span><br><span class="line">2.分叉情况：</span><br><span class="line">      定义:</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h1 id="比特币系统架构"><a href="#比特币系统架构" class="headerlink" title="比特币系统架构"></a>比特币系统架构</h1><h2 id="比特币系统逻辑结构"><a href="#比特币系统逻辑结构" class="headerlink" title="比特币系统逻辑结构"></a>比特币系统逻辑结构</h2><ul><li><p>应用层:</p><ul><li>收付款</li><li>交易记录</li><li>区块查询</li></ul></li><li><p>激励层:</p><ul><li>发行机制</li><li>分配机制</li></ul></li><li><p>共识层:</p><ul><li>工作量证明(Pow)</li></ul></li><li><p>网络层:</p><ul><li>P2P网络</li><li>传播机制</li><li>验证机制</li></ul></li><li><p>数据层:</p><ul><li>区块数据</li><li>链式结构</li><li>数字签名</li><li>哈希函数</li><li>默克尔树</li><li>非对称加密</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ·比特币 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/hexoblog.github.io/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"/>
      <url>/hexoblog.github.io/2022/06/01/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="这是H1标题"><a href="#这是H1标题" class="headerlink" title="这是H1标题"></a>这是H1标题</h1><h2 id="这是H2标题"><a href="#这是H2标题" class="headerlink" title="这是H2标题"></a>这是H2标题</h2><p>这是第一段：学余时间的探索和慢慢儿的学习…教程来源于互联网，小白入场，一切稳步进行？….</p><p>这是第二段？…<br>这是第三段？</p><h3 id="这是H3标题"><a href="#这是H3标题" class="headerlink" title="这是H3标题"></a>这是H3标题</h3><p>这是第四段<strong>加粗</strong></p><h4 id="这是H4标题"><a href="#这是H4标题" class="headerlink" title="这是H4标题"></a>这是H4标题</h4><blockquote><p>这是引用</p></blockquote><h4 id="这是H4标题-1"><a href="#这是H4标题-1" class="headerlink" title="这是H4标题"></a>这是H4标题</h4><blockquote><p>这是个</p><p>块引用</p></blockquote><h4 id="这是H4标题-2"><a href="#这是H4标题-2" class="headerlink" title="这是H4标题"></a>这是H4标题</h4><blockquote><p>这是个</p><blockquote><p>嵌套块引用</p></blockquote></blockquote><h5 id="这是个H5标题"><a href="#这是个H5标题" class="headerlink" title="这是个H5标题"></a>这是个H5标题</h5><blockquote><p>也许看起来不错<br>支持块引用包含其他Markdown 格式的元素<br>www<strong>内含加粗</strong>ww</p></blockquote><h6 id="这是H6标题"><a href="#这是H6标题" class="headerlink" title="这是H6标题"></a>这是H6标题</h6><ol><li>有序列表.</li><li>列表应该以数字1起始.</li><li>结尾需要英文句号.</li><li>无英文句号结尾</li></ol><h6 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h6><ul><li>这是无序列表有英文句号结尾</li><li>这是无序列表无英文句号结尾</li><li>这是无序列表<ul><li>这是嵌套无序列表01</li><li>这是嵌套无序列表02</li></ul></li></ul><h2 id="代码语法"><a href="#代码语法" class="headerlink" title="代码语法"></a>代码语法</h2><p>代码语法01：<code>user01</code> <code>user02``user03</code><br>代码语法02： <code>user `多个引号`</code></p><h3 id="这是H3标题-1"><a href="#这是H3标题-1" class="headerlink" title="这是H3标题"></a>这是H3标题</h3><hr><p>分割线：为了兼容性，在分隔线前后添加空白行</p><hr><h3 id="链接语法"><a href="#链接语法" class="headerlink" title="链接语法"></a>链接语法</h3><p>这是一个链接：<a href="https://markdown.com.cn/">https://markdown.com.cn</a></p><p>##图片</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hexoblog.github.io/2022/04/12/hello-world/"/>
      <url>/hexoblog.github.io/2022/04/12/hello-world/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
